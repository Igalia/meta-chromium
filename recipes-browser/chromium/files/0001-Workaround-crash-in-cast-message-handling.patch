From 1d3d6923aa8a7178c5f25b0a55b82cecc4ce2793 Mon Sep 17 00:00:00 2001
From: Stephan Hartmann <stha09@googlemail.com>
Date: Tue, 20 Jul 2021 20:40:12 +0200
Subject: Workaround crash in cast message handling.

Imported from Gentoo:
https://gitweb.gentoo.org/repo/gentoo.git/commit/?id=c580af0345725e2d81819433a0de30629326e226

Change-Id: Ib824303724c2b266c85da46610b62ae5d4efd553
---
 components/cast_channel/enum_table.h | 20 +++++++++-----------
 1 file changed, 9 insertions(+), 11 deletions(-)

diff --git a/components/cast_channel/enum_table.h b/components/cast_channel/enum_table.h
index a63ae86cf1adc..83ada659b4559 100644
--- a/components/cast_channel/enum_table.h
+++ b/components/cast_channel/enum_table.h
@@ -8,6 +8,7 @@
 #include <cstdint>
 #include <cstring>
 #include <ostream>
+#include <vector>
 
 #include "base/check_op.h"
 #include "base/macros.h"
@@ -213,7 +214,7 @@ class
 
   template <typename E>
   friend class EnumTable;
-  DISALLOW_COPY_AND_ASSIGN(GenericEnumTableEntry);
+  DISALLOW_ASSIGN(GenericEnumTableEntry);
 };
 
 // Yes, these constructors really needs to be inlined.  Even though they look
@@ -251,8 +252,7 @@ class EnumTable {
     // Constructor for regular entries.
     constexpr Entry(E value, base::StringPiece str)
         : GenericEnumTableEntry(static_cast<int32_t>(value), str) {}
-
-    DISALLOW_COPY_AND_ASSIGN(Entry);
+    DISALLOW_ASSIGN(Entry);
   };
 
   static_assert(sizeof(E) <= sizeof(int32_t),
@@ -307,15 +307,14 @@ class EnumTable {
     if (is_sorted_) {
       const std::size_t index = static_cast<std::size_t>(value);
       if (ANALYZER_ASSUME_TRUE(index < data_.size())) {
-        const auto& entry = data_.begin()[index];
+        const auto& entry = data_[index];
         if (ANALYZER_ASSUME_TRUE(entry.has_str()))
           return entry.str();
       }
       return absl::nullopt;
     }
     return GenericEnumTableEntry::FindByValue(
-        reinterpret_cast<const GenericEnumTableEntry*>(data_.begin()),
-        data_.size(), static_cast<int32_t>(value));
+        &data_[0], data_.size(), static_cast<int32_t>(value));
   }
 
   // This overload of GetString is designed for cases where the argument is a
@@ -343,8 +342,7 @@ class EnumTable {
   // enum value directly.
   absl::optional<E> GetEnum(base::StringPiece str) const {
     auto* entry = GenericEnumTableEntry::FindByString(
-        reinterpret_cast<const GenericEnumTableEntry*>(data_.begin()),
-        data_.size(), str);
+        &data_[0], data_.size(), str);
     return entry ? static_cast<E>(entry->value) : absl::optional<E>();
   }
 
@@ -359,7 +357,7 @@ class EnumTable {
   // Align the data on a cache line boundary.
   alignas(64)
 #endif
-      std::initializer_list<Entry> data_;
+      const std::vector<Entry> data_;
   bool is_sorted_;
 
   constexpr EnumTable(std::initializer_list<Entry> data, bool is_sorted)
@@ -371,8 +369,8 @@ class EnumTable {
 
     for (std::size_t i = 0; i < data.size(); i++) {
       for (std::size_t j = i + 1; j < data.size(); j++) {
-        const Entry& ei = data.begin()[i];
-        const Entry& ej = data.begin()[j];
+        const Entry& ei = data[i];
+        const Entry& ej = data[j];
         DCHECK(ei.value != ej.value)
             << "Found duplicate enum values at indices " << i << " and " << j;
         DCHECK(!(ei.has_str() && ej.has_str() && ei.str() == ej.str()))
-- 
2.30.2

