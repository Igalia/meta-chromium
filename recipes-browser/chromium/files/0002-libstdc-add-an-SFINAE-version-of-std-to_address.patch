From 1949ed0483f66c5e050cad71be693c15210e2f55 Mon Sep 17 00:00:00 2001
From: Jose Dapena Paz <jdapena@igalia.com>
Date: Tue, 19 Dec 2023 15:07:35 +0100
Subject: libstdc++: add an SFINAE version of std::to_address

Bug: 957519
Change-Id: I42ab30a9df8f99f350c17549e954f7a8c2f64d77
---
 base/BUILD.gn                             |  1 +
 base/types/to_address.h                   | 88 +++++++++++++++++++++++
 mojo/public/cpp/bindings/type_converter.h |  6 +-
 3 files changed, 93 insertions(+), 2 deletions(-)
 create mode 100644 base/types/to_address.h

diff --git a/base/BUILD.gn b/base/BUILD.gn
index 9002f101ee58f..d5ee9df5507ad 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -937,6 +937,7 @@ component("base") {
     "types/pass_key.h",
     "types/strong_alias.h",
     "types/supports_ostream_operator.h",
+    "types/to_address.h",
     "types/token_type.h",
     "types/variant_util.h",
     "unguessable_token.cc",
diff --git a/base/types/to_address.h b/base/types/to_address.h
new file mode 100644
index 0000000000000..9b6533c7d591b
--- /dev/null
+++ b/base/types/to_address.h
@@ -0,0 +1,88 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_TYPES_TO_ADDRESS_H_
+#define BASE_TYPES_TO_ADDRESS_H_
+
+#include <memory>
+#include <type_traits>
+
+namespace base {
+
+// SFINAE wrapper of std::to_address
+//
+// Though libc++ std::to_address is SFINAE, libstdc++ is not, and standard
+// does not specify it should be in C++20. So wrap in a SFINAE version for
+// anything that is not libc++, and just use std::to_address in libc++
+
+#if defined(_LIBCPP_VERSION)
+using std::to_address;
+#else
+
+template <class Pointer, class = void>
+struct to_address_helper;
+
+template <class T>
+constexpr T* to_address(T* p) noexcept {
+  static_assert(!std::is_function<T>::value, "T is a function type");
+  return p;
+}
+
+// The helper methods for making base::to_address SFINAE are based on libc++
+// implementation
+template <class P, class = void>
+struct has_to_address : std::false_type {};
+
+template <class P>
+struct has_to_address<P,
+                      decltype((void)std::pointer_traits<P>::to_address(
+                          std::declval<const P&>()))> : std::true_type {};
+
+template <class P, class = void>
+struct has_arrow : std::false_type {};
+
+template <class P>
+struct has_arrow<P, decltype((void)std::declval<const P&>().operator->())>
+    : std::true_type {};
+
+template <class P>
+struct is_fancy_pointer {
+  static const bool value = has_arrow<P>::value || has_to_address<P>::value;
+};
+
+// enable_if is needed here to avoid instantiating checks for fancy pointers on
+// raw pointers
+template <class P,
+          class = std::enable_if_t<
+              std::conjunction<std::is_class<P>, is_fancy_pointer<P>>::value>>
+constexpr std::decay_t<
+    decltype(to_address_helper<P>::__call(std::declval<const P&>()))>
+to_address(const P& p) noexcept {
+  return to_address_helper<P>::__call(p);
+}
+
+template <class P, class>
+struct to_address_helper {
+  constexpr static decltype(to_address(std::declval<const P&>().operator->()))
+  __call(const P& p) noexcept {
+    return to_address(p.operator->());
+  }
+};
+
+template <class P>
+struct to_address_helper<P,
+                         decltype((void)std::pointer_traits<P>::to_address(
+                             std::declval<const P&>()))> {
+  constexpr static decltype(std::pointer_traits<P>::to_address(
+      std::declval<const P&>()))
+  __call(const P& p) noexcept {
+    return std::pointer_traits<P>::to_address(p);
+  }
+};
+
+#endif  // defined(_LIBCPP_VERSION)
+
+}  // namespace base
+
+#endif  // BASE_TYPES_CXX23_TO_UNDERLYING_H_
diff --git a/mojo/public/cpp/bindings/type_converter.h b/mojo/public/cpp/bindings/type_converter.h
index c2edc879afb86..d7cfbc75a8ae7 100644
--- a/mojo/public/cpp/bindings/type_converter.h
+++ b/mojo/public/cpp/bindings/type_converter.h
@@ -11,6 +11,8 @@
 #include <memory>
 #include <type_traits>
 
+#include <base/types/to_address.h>
+
 namespace mojo {
 
 // NOTE: When possible, please consider using StructTraits / UnionTraits /
@@ -98,10 +100,10 @@ inline T ConvertTo(U* obj) {
 template <typename T, typename U>
   requires requires(const U& obj) {
     not std::is_pointer_v<U>;
-    { mojo::ConvertTo<T>(std::to_address(obj)) } -> std::same_as<T>;
+    { mojo::ConvertTo<T>(base::to_address(obj)) } -> std::same_as<T>;
   }
 inline T ConvertTo(const U& obj) {
-  return mojo::ConvertTo<T>(std::to_address(obj));
+  return mojo::ConvertTo<T>(base::to_address(obj));
 }
 
 template <typename T, typename U>
-- 
2.40.1

