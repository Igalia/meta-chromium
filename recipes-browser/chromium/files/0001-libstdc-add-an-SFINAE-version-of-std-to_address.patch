From 50a7c347b1e37dd2341d89487a2ff314af8a399a Mon Sep 17 00:00:00 2001
From: Jose Dapena Paz <jdapena@igalia.com>
Date: Tue, 19 Dec 2023 15:07:35 +0100
Subject: libstdc++: add an SFINAE version of std::to_address

Bug: 957519
Change-Id: I42ab30a9df8f99f350c17549e954f7a8c2f64d77
---
 base/BUILD.gn                             |  1 +
 base/types/to_address.h                   | 82 +++++++++++++++++++++++
 mojo/public/cpp/bindings/type_converter.h |  7 +-
 3 files changed, 87 insertions(+), 3 deletions(-)
 create mode 100644 base/types/to_address.h

diff --git a/base/BUILD.gn b/base/BUILD.gn
index e54d9ff43f3ab..e4c0b361703fb 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -924,6 +924,7 @@ component("base") {
     "types/pass_key.h",
     "types/strong_alias.h",
     "types/supports_ostream_operator.h",
+    "types/to_address.h",
     "types/token_type.h",
     "types/variant_util.h",
     "unguessable_token.cc",
diff --git a/base/types/to_address.h b/base/types/to_address.h
new file mode 100644
index 0000000000000..916032a8b9ede
--- /dev/null
+++ b/base/types/to_address.h
@@ -0,0 +1,82 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_TYPES_TO_ADDRESS_H_
+#define BASE_TYPES_TO_ADDRESS_H_
+
+#include <type_traits>
+
+namespace base {
+
+// SFINAE wrapper of std::to_address
+//
+// Though libc++ std::to_address is SFINAE, libstdc++ is not, and standard
+// does not specify it should be in C++20. So wrap in a SFINAE version for
+// anything that is not libc++, and just use std::to_address in libc++
+
+#if defined(_LIBCPP_VERSION)
+using to_address = std::to_address;
+#else
+
+template <class Pointer, class = void>
+struct ToAddressHelper;
+
+template <class T>
+constexpr T* ToAddress(T* p) noexcept {
+  static_assert(!std::is_function<T>::value, "T is a function type");
+  return p;
+}
+
+// The helper methods for making base::ToAddress SFINAE are based on libc++
+// implementation
+template <class P, class = void>
+struct HasToAddress : std::false_type {};
+
+template <class P>
+struct HasToAddress<P, decltype((void)std::pointer_traits<P>::to_address(std::declval<const P&>())) >
+    : std::true_type {};
+
+template <class P, class = void>
+struct HasArrow : std::false_type {};
+
+template <class P>
+struct HasArrow<P, decltype((void)std::declval<const P&>().operator->()) > : std::true_type {};
+
+template <class P>
+struct IsFancyPointer {
+  static const bool value = HasArrow<P>::value || HasToAddress<P>::value;
+};
+
+// enable_if is needed here to avoid instantiating checks for fancy pointers on raw pointers
+template <class P, class = std::enable_if_t<std::conjunction<std::is_class<P>, IsFancyPointer<P> >::value > >
+constexpr
+    std::decay_t<decltype(ToAddressHelper<P>::__call(std::declval<const P&>()))>
+    ToAddress(const P& p) noexcept {
+  return ToAddressHelper<P>::__call(p);
+}
+
+template <class P, class>
+struct ToAddressHelper {
+  constexpr static decltype(ToAddress(
+      std::declval<const P&>().operator->()))
+  __call(const P& p) noexcept {
+    return ToAddress(p.operator->());
+  }
+};
+
+template <class P>
+struct ToAddressHelper<P,
+                       decltype((void)std::pointer_traits<P>::to_address(std::declval<const P&>()))> {
+  constexpr static decltype(std::pointer_traits<P>::to_address(
+      std::declval<const P&>()))
+  __call(const P& p) noexcept {
+    return std::pointer_traits<P>::to_address(p);
+  }
+};
+
+#endif  // defined(_LIBCPP_VERSION)
+
+}  // namespace base
+
+#endif  // BASE_TYPES_CXX23_TO_UNDERLYING_H_
diff --git a/mojo/public/cpp/bindings/type_converter.h b/mojo/public/cpp/bindings/type_converter.h
index 2eddbb0460cd4..cbaa4e0f02295 100644
--- a/mojo/public/cpp/bindings/type_converter.h
+++ b/mojo/public/cpp/bindings/type_converter.h
@@ -11,6 +11,8 @@
 #include <memory>
 #include <type_traits>
 
+#include <base/types/to_address.h>
+
 namespace mojo {
 
 // NOTE: When possible, please consider using StructTraits / UnionTraits /
@@ -100,11 +102,10 @@ template <typename T, typename U>
 inline T ConvertTo(const U& obj) {
   if constexpr (requires {
                   {
-                    mojo::ConvertTo<T>(std::to_address(obj))
-
+                    mojo::ConvertTo<T>(base::ToAddress(obj))
                   } -> std::same_as<T>;
                 }) {
-    return mojo::ConvertTo<T>(std::to_address(obj));
+    return mojo::ConvertTo<T>(base::ToAddress(obj));
   } else {
     return TypeConverter<T, U>::Convert(obj);
   }
-- 
2.40.1

