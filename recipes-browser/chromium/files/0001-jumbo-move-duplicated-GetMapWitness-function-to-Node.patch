From 65b7ef791769f890c1abc33abd67e5a62b42ab93 Mon Sep 17 00:00:00 2001
From: Mostyn Bramley-Moore <mostynb@vewd.com>
Date: Thu, 4 Jan 2018 08:45:13 +0100
Subject: [jumbo] move duplicated GetMapWitness function to NodeProperties

Bug: v8:7127, v8:7204, v8:7205
Change-Id: Iedea388590991e4d0edcf59e02c767b6c04460e7
Reviewed-on: https://chromium-review.googlesource.com/849216
Reviewed-by: Benedikt Meurer <bmeurer@chromium.org>
Commit-Queue: Mostyn Bramley-Moore <mostynb@vewd.com>
Cr-Commit-Position: refs/heads/master@{#50351}

diff --git a/src/compiler/js-builtin-reducer.cc b/src/compiler/js-builtin-reducer.cc
index ef07ce3826..18cfac9866 100644
--- a/src/compiler/js-builtin-reducer.cc
+++ b/src/compiler/js-builtin-reducer.cc
@@ -109,18 +109,6 @@ JSBuiltinReducer::JSBuiltinReducer(Editor* editor, JSGraph* jsgraph,
 
 namespace {
 
-MaybeHandle<Map> GetMapWitness(Node* node) {
-  ZoneHandleSet<Map> maps;
-  Node* receiver = NodeProperties::GetValueInput(node, 1);
-  Node* effect = NodeProperties::GetEffectInput(node);
-  NodeProperties::InferReceiverMapsResult result =
-      NodeProperties::InferReceiverMaps(receiver, effect, &maps);
-  if (result == NodeProperties::kReliableReceiverMaps && maps.size() == 1) {
-    return maps[0];
-  }
-  return MaybeHandle<Map>();
-}
-
 Maybe<InstanceType> GetInstanceTypeWitness(Node* node) {
   ZoneHandleSet<Map> maps;
   Node* receiver = NodeProperties::GetValueInput(node, 1);
@@ -174,7 +162,7 @@ bool CanInlineJSArrayIteration(Handle<Map> receiver_map) {
 Reduction JSBuiltinReducer::ReduceArrayIterator(Node* node,
                                                 IterationKind kind) {
   Handle<Map> receiver_map;
-  if (GetMapWitness(node).ToHandle(&receiver_map)) {
+  if (NodeProperties::GetMapWitness(node).ToHandle(&receiver_map)) {
     return ReduceArrayIterator(receiver_map, node, kind,
                                ArrayIteratorKind::kArray);
   }
@@ -184,7 +172,7 @@ Reduction JSBuiltinReducer::ReduceArrayIterator(Node* node,
 Reduction JSBuiltinReducer::ReduceTypedArrayIterator(Node* node,
                                                      IterationKind kind) {
   Handle<Map> receiver_map;
-  if (GetMapWitness(node).ToHandle(&receiver_map) &&
+  if (NodeProperties::GetMapWitness(node).ToHandle(&receiver_map) &&
       receiver_map->instance_type() == JS_TYPED_ARRAY_TYPE) {
     return ReduceArrayIterator(receiver_map, node, kind,
                                ArrayIteratorKind::kTypedArray);
diff --git a/src/compiler/js-call-reducer.cc b/src/compiler/js-call-reducer.cc
index 28b22919c6..dcd6fb0ff6 100644
--- a/src/compiler/js-call-reducer.cc
+++ b/src/compiler/js-call-reducer.cc
@@ -3366,18 +3366,6 @@ bool CanInlineArrayResizeOperation(Handle<Map> receiver_map) {
          !IsReadOnlyLengthDescriptor(receiver_map);
 }
 
-MaybeHandle<Map> GetMapWitness(Node* node) {
-  ZoneHandleSet<Map> maps;
-  Node* receiver = NodeProperties::GetValueInput(node, 1);
-  Node* effect = NodeProperties::GetEffectInput(node);
-  NodeProperties::InferReceiverMapsResult result =
-      NodeProperties::InferReceiverMaps(receiver, effect, &maps);
-  if (result == NodeProperties::kReliableReceiverMaps && maps.size() == 1) {
-    return maps[0];
-  }
-  return MaybeHandle<Map>();
-}
-
 }  // namespace
 
 // ES6 section 22.1.3.18 Array.prototype.push ( )
@@ -3500,7 +3488,7 @@ Reduction JSCallReducer::ReduceArrayPrototypePop(Node* node) {
   Node* control = NodeProperties::GetControlInput(node);
   // TODO(turbofan): Extend this to also handle fast holey double elements
   // once we got the hole NaN mess sorted out in TurboFan/V8.
-  if (GetMapWitness(node).ToHandle(&receiver_map) &&
+  if (NodeProperties::GetMapWitness(node).ToHandle(&receiver_map) &&
       CanInlineArrayResizeOperation(receiver_map) &&
       receiver_map->elements_kind() != HOLEY_DOUBLE_ELEMENTS) {
     // Install code dependencies on the {receiver} prototype maps and the
@@ -3597,7 +3585,7 @@ Reduction JSCallReducer::ReduceArrayPrototypeShift(Node* node) {
   // TODO(turbofan): Extend this to also handle fast holey double elements
   // once we got the hole NaN mess sorted out in TurboFan/V8.
   Handle<Map> receiver_map;
-  if (GetMapWitness(node).ToHandle(&receiver_map) &&
+  if (NodeProperties::GetMapWitness(node).ToHandle(&receiver_map) &&
       CanInlineArrayResizeOperation(receiver_map) &&
       receiver_map->elements_kind() != HOLEY_DOUBLE_ELEMENTS) {
     // Install code dependencies on the {receiver} prototype maps and the
diff --git a/src/compiler/node-properties.cc b/src/compiler/node-properties.cc
index f8001a4eda..bcfb035a58 100644
--- a/src/compiler/node-properties.cc
+++ b/src/compiler/node-properties.cc
@@ -12,6 +12,7 @@
 #include "src/compiler/simplified-operator.h"
 #include "src/compiler/verifier.h"
 #include "src/handles-inl.h"
+#include "src/zone/zone-handle-set.h"
 
 namespace v8 {
 namespace internal {
@@ -500,6 +501,19 @@ NodeProperties::InferReceiverMapsResult NodeProperties::InferReceiverMaps(
   }
 }
 
+// static
+MaybeHandle<Map> NodeProperties::GetMapWitness(Node* node) {
+  ZoneHandleSet<Map> maps;
+  Node* receiver = NodeProperties::GetValueInput(node, 1);
+  Node* effect = NodeProperties::GetEffectInput(node);
+  NodeProperties::InferReceiverMapsResult result =
+      NodeProperties::InferReceiverMaps(receiver, effect, &maps);
+  if (result == NodeProperties::kReliableReceiverMaps && maps.size() == 1) {
+    return maps[0];
+  }
+  return MaybeHandle<Map>();
+}
+
 // static
 bool NodeProperties::NoObservableSideEffectBetween(Node* effect,
                                                    Node* dominator) {
diff --git a/src/compiler/node-properties.h b/src/compiler/node-properties.h
index 5ccc15c1ab..abc6622c83 100644
--- a/src/compiler/node-properties.h
+++ b/src/compiler/node-properties.h
@@ -8,6 +8,7 @@
 #include "src/compiler/node.h"
 #include "src/compiler/types.h"
 #include "src/globals.h"
+#include "src/objects/map.h"
 #include "src/zone/zone-handle-set.h"
 
 namespace v8 {
@@ -153,6 +154,8 @@ class V8_EXPORT_PRIVATE NodeProperties final {
   static InferReceiverMapsResult InferReceiverMaps(
       Node* receiver, Node* effect, ZoneHandleSet<Map>* maps_return);
 
+  static MaybeHandle<Map> GetMapWitness(Node* node);
+
   // Walks up the {effect} chain to check that there's no observable side-effect
   // between the {effect} and it's {dominator}. Aborts the walk if there's join
   // in the effect chain.
-- 
2.14.1

