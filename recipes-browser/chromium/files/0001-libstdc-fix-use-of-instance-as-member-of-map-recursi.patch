From 2a196bc5d0d51df352012921eab23b9a4d36a603 Mon Sep 17 00:00:00 2001
From: Stephan Hartmann <stha09@googlemail.com>
Date: Fri, 11 Feb 2022 11:10:53 +0000
Subject: libstdc++: fix use of instance as member of map recursing to parent

Chromium fails to build HistoryFuzzyProvider because the struct Node
contains an unordered_map of itself. At declaration Node cannot be
instaciated because its size is unknown. libstdc++ implementation
requires to know its size.

The solution is to wrap with std::reference_wrapper.

Bug: 957519
Change-Id: I79a795372f87d6185f71eb00cb37d42b9d43fb3f
---
 .../omnibox/browser/history_fuzzy_provider.cc      | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/components/omnibox/browser/history_fuzzy_provider.cc b/components/omnibox/browser/history_fuzzy_provider.cc
index fdec1f9ff31aa..16a30ac3743d9 100644
--- a/components/omnibox/browser/history_fuzzy_provider.cc
+++ b/components/omnibox/browser/history_fuzzy_provider.cc
@@ -5,6 +5,7 @@
 #include "components/omnibox/browser/history_fuzzy_provider.h"
 
 #include <algorithm>
+#include <functional>
 #include <unordered_map>
 #include <utility>
 #include <vector>
@@ -65,7 +66,7 @@ struct Correction {
 
 struct Node {
   int relevance = 0;
-  std::unordered_map<char16_t, Node> next;
+  std::unordered_map<char16_t, std::reference_wrapper<Node>> next;
 
   void Insert(const std::u16string& text, size_t from) {
     if (from >= text.length()) {
@@ -73,7 +74,7 @@ struct Node {
       return;
     }
     char16_t c = text[from];
-    Node& node = next[c];
+    Node& node = next.at(c);
     node.Insert(text, from + 1);
   }
 
@@ -113,8 +114,8 @@ struct Node {
         // insertion, not only replacement. Change `from` parameter and modify
         // correction accordingly.
         std::vector<Correction> subcorrections;
-        bool found = entry.second.FindCorrections(text, from + 1, tolerance - 1,
-                                                  subcorrections);
+        bool found = entry.second.get().FindCorrections(
+            text, from + 1, tolerance - 1, subcorrections);
         if (found) {
           // Remaining input without further correction is on trie.
           corrections.emplace_back(from, entry.first);
@@ -134,7 +135,8 @@ struct Node {
       return false;
     } else {
       // Found; proceed with tolerance.
-      return it->second.FindCorrections(text, from + 1, tolerance, corrections);
+      return it->second.get().FindCorrections(text, from + 1, tolerance,
+                                              corrections);
     }
   }
 
@@ -146,7 +148,7 @@ struct Node {
       DVLOG(1) << "  <" << built << ">";
     }
     for (const auto& entry : next) {
-      entry.second.Log(built + entry.first);
+      entry.second.get().Log(built + entry.first);
     }
   }
 };
-- 
2.32.0

