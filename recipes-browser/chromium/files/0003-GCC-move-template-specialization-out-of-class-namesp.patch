From cd34e230a16118049ccf22b92c3290498f796f25 Mon Sep 17 00:00:00 2001
From: Jose Dapena Paz <jdapena@igalia.com>
Date: Wed, 14 Feb 2024 12:03:15 +0100
Subject: GCC: move template specialization out of class namespace in
 media_devices.cc

GCC does not allow template specializations in class namespaces, and
they should go in namespace scope.

Bug: 40565911
Change-Id: I34e7dbe2fc988d5580ee1fd8417039571c47d254
---
 .../modules/mediastream/media_devices.cc      | 79 ++++++++++---------
 1 file changed, 41 insertions(+), 38 deletions(-)

diff --git a/third_party/blink/renderer/modules/mediastream/media_devices.cc b/third_party/blink/renderer/modules/mediastream/media_devices.cc
index 1e1eb23b07991..1e369fca469a5 100644
--- a/third_party/blink/renderer/modules/mediastream/media_devices.cc
+++ b/third_party/blink/renderer/modules/mediastream/media_devices.cc
@@ -104,35 +104,6 @@ class PromiseResolverCallbacks final : public UserMediaRequest::Callbacks {
   template <typename T>
   void OnSuccessImpl(const MediaStreamVector&, CaptureController*);
 
-  template <>
-  void OnSuccessImpl<MediaStream>(const MediaStreamVector& streams,
-                                  CaptureController* capture_controller) {
-    DCHECK_EQ(streams.size(), 1u);
-    MediaStream* stream = streams[0];
-
-    if (on_success_follow_up_) {
-      // Only getDisplayMedia() calls set |on_success_follow_up_|.
-      // Successful invocations of getDisplayMedia() always have exactly
-      // one video track.
-      //
-      // Extension API calls that are followed by a getUserMedia() call with
-      // chromeMediaSourceId are treated liked getDisplayMedia() calls.
-      MediaStreamTrackVector video_tracks = stream->getVideoTracks();
-      DCHECK_EQ(video_tracks.size(), 1u);
-      if (capture_controller) {
-        capture_controller->SetVideoTrack(video_tracks[0], stream->id().Utf8());
-      }
-    }
-
-    // Resolve Promise<MediaStream> on a microtask.
-    resolver_->Resolve(stream);
-
-    // Enqueue the follow-up microtask, if any is intended.
-    if (on_success_follow_up_) {
-      std::move(on_success_follow_up_).Run(stream->id(), capture_controller);
-    }
-  }
-
   void OnError(ScriptWrappable* callback_this_value,
                const V8MediaStreamError* error,
                CaptureController* capture_controller,
@@ -148,15 +119,6 @@ class PromiseResolverCallbacks final : public UserMediaRequest::Callbacks {
     UserMediaRequest::Callbacks::Trace(visitor);
   }
 
-  template <>
-  void OnSuccessImpl<IDLSequence<MediaStream>>(
-      const MediaStreamVector& streams,
-      CaptureController* capture_controller) {
-    DCHECK(!streams.empty());
-    DCHECK_EQ(UserMediaRequestType::kAllScreensMedia, media_type_);
-    resolver_->Resolve(streams);
-  }
-
  private:
   const UserMediaRequestType media_type_;
 
@@ -167,6 +129,47 @@ class PromiseResolverCallbacks final : public UserMediaRequest::Callbacks {
       on_success_follow_up_;
 };
 
+template <>
+template <>
+void PromiseResolverCallbacks<MediaStream>::OnSuccessImpl<MediaStream>(
+    const MediaStreamVector& streams,
+    CaptureController* capture_controller) {
+  DCHECK_EQ(streams.size(), 1u);
+  MediaStream* stream = streams[0];
+
+  if (on_success_follow_up_) {
+    // Only getDisplayMedia() calls set |on_success_follow_up_|.
+    // Successful invocations of getDisplayMedia() always have exactly
+    // one video track.
+    //
+    // Extension API calls that are followed by a getUserMedia() call with
+    // chromeMediaSourceId are treated liked getDisplayMedia() calls.
+    MediaStreamTrackVector video_tracks = stream->getVideoTracks();
+    DCHECK_EQ(video_tracks.size(), 1u);
+    if (capture_controller) {
+      capture_controller->SetVideoTrack(video_tracks[0], stream->id().Utf8());
+    }
+  }
+
+  // Resolve Promise<MediaStream> on a microtask.
+  resolver_->Resolve(stream);
+
+  // Enqueue the follow-up microtask, if any is intended.
+  if (on_success_follow_up_) {
+    std::move(on_success_follow_up_).Run(stream->id(), capture_controller);
+  }
+}
+
+template <>
+template <>
+void PromiseResolverCallbacks<IDLSequence<MediaStream>>::OnSuccessImpl<
+    IDLSequence<MediaStream>>(const MediaStreamVector& streams,
+                              CaptureController* capture_controller) {
+  DCHECK(!streams.empty());
+  DCHECK_EQ(UserMediaRequestType::kAllScreensMedia, media_type_);
+  resolver_->Resolve(streams);
+}
+
 // These values are persisted to logs. Entries should not be renumbered and
 // numeric values should never be reused.
 enum class DisplayCapturePolicyResult {
-- 
2.40.1

