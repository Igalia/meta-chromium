From 27be178c0a105b1240b7f45d66b836e3b8ea44b9 Mon Sep 17 00:00:00 2001
From: Jose Dapena Paz <jdapena@igalia.com>
Date: Tue, 16 Jun 2020 17:19:01 +0200
Subject: GCC: avoid clash between generated type x11::RandR::Connection and
 x11::Connection.

gen_xproto.py is generating the type x11::RandR::Connection. In the case it is
built with GCC, it will complain because it clashes with the declaration of
x11::Connection. To avoid this problem, this patch modified the script to
add an exception for Connection type, to rename it to RandRConnection.

This change also modified the calls using this type in x11_display_util.cc

Bug: 819294
Change-Id: Ic09b6835261b3f48fb1c43e6a258fac539889d1a
---
 ui/base/x/x11_display_util.cc |  4 ++--
 ui/gfx/x/gen_xproto.py        | 11 ++++++-----
 2 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/ui/base/x/x11_display_util.cc b/ui/base/x/x11_display_util.cc
index 739e2722fafa..92bec3abcd49 100644
--- a/ui/base/x/x11_display_util.cc
+++ b/ui/base/x/x11_display_util.cc
@@ -236,7 +236,7 @@ std::vector<display::Display> BuildDisplaysFromXRandRInfo(
     if (!output_info)
       continue;
 
-    if (output_info->connection != x11::RandR::Connection::Connected)
+    if (output_info->connection != x11::RandR::RandRConnection::Connected)
       continue;
 
     bool is_primary_display = (output_id == primary_display_id);
@@ -362,7 +362,7 @@ base::TimeDelta GetPrimaryDisplayRefreshIntervalFromXrandr() {
     if (!output_info)
       continue;
 
-    if (output_info->connection != x11::RandR::Connection::Connected) {
+    if (output_info->connection != x11::RandR::RandRConnection::Connected) {
       // If the primary monitor is disconnected, then start over and choose the
       // first connected monitor instead.
       if (!disconnected_primary) {
diff --git a/ui/gfx/x/gen_xproto.py b/ui/gfx/x/gen_xproto.py
index 98efeec2b811..5ef8a0a405d2 100644
--- a/ui/gfx/x/gen_xproto.py
+++ b/ui/gfx/x/gen_xproto.py
@@ -185,6 +185,7 @@ RENAME = {
     'CHARINFO': 'CharInfo',
     'COLORITEM': 'ColorItem',
     'COLORMAP': 'ColorMap',
+    'Connection': 'RandRConnection',
     'CP': 'CreatePictureAttribute',
     'CW': 'CreateWindowAttribute',
     'DAMAGE': 'DamageId',
@@ -232,7 +233,7 @@ WRITE_SPECIAL = set([
 ])
 
 
-def adjust_type_case(name):
+def adjust_type_name(name):
     if name in RENAME:
         return RENAME[name]
     # If there's an underscore, then this is either snake case or upper case.
@@ -392,7 +393,7 @@ class GenXproto(FileWriter):
             name[0] = 'x11'
 
         for i in range(1, len(name)):
-            name[i] = adjust_type_case(name[i])
+            name[i] = adjust_type_name(name[i])
         name[-1] += self.type_suffix(t)
         return name
 
@@ -771,7 +772,7 @@ class GenXproto(FileWriter):
         self.undef(enum.name[-1])
         with Indent(
                 self, 'enum class %s : %s {' %
-            (adjust_type_case(enum.name[-1]), self.enum_types[enum.name][0]
+            (adjust_type_name(enum.name[-1]), self.enum_types[enum.name][0]
              if enum.name in self.enum_types else 'int'), '};'):
             bitnames = set([name for name, _ in enum.bits])
             for name, value in enum.values:
@@ -801,7 +802,7 @@ class GenXproto(FileWriter):
     def declare_container(self, struct, struct_name):
         name = struct_name[-1] + self.type_suffix(struct)
         self.undef(name)
-        with Indent(self, 'struct %s {' % adjust_type_case(name), '};'):
+        with Indent(self, 'struct %s {' % adjust_type_name(name), '};'):
             if struct.is_event:
                 self.write('static constexpr uint8_t opcode = %s;' %
                            struct.opcodes[struct_name])
@@ -1014,7 +1015,7 @@ class GenXproto(FileWriter):
     # Perform preprocessing like renaming, reordering, and adding additional
     # data fields.
     def resolve(self):
-        self.class_name = (adjust_type_case(self.module.namespace.ext_name)
+        self.class_name = (adjust_type_name(self.module.namespace.ext_name)
                            if self.module.namespace.is_ext else 'XProto')
         for i, (name, t) in enumerate(self.module.all):
             # Work around a name conflict: the type ScreenSaver has the same
-- 
2.20.1

