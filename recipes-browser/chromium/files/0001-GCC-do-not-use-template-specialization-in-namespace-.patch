From 2c6ce68b568ff0c357cb02ce717260760652e278 Mon Sep 17 00:00:00 2001
From: Jose Dapena Paz <jdapena@igalia.com>
Date: Tue, 1 Sep 2020 20:07:32 +0200
Subject: GCC: do not use template specialization in namespace for
 SequenceBound::AsyncCallWithBoundArgsBuilder

GCC does not allow template specialization inside a namespace,
so it is not possible to implement SequenceBound::AsyncCallWithBoundArgsBuilder
as such. To fix that, we use a combination of regular if with std::is_same (in
destructor) and std::enable_if_t for the Then method with OnceCallback.

Bug: 819294
Change-Id: Id822b653b04a4c28d28c9187051d130f4e665069
---
 base/threading/sequence_bound.h | 43 +++++++++++----------------------
 1 file changed, 14 insertions(+), 29 deletions(-)

diff --git a/base/threading/sequence_bound.h b/base/threading/sequence_bound.h
index 217a1d53a698..d88234bb44bb 100644
--- a/base/threading/sequence_bound.h
+++ b/base/threading/sequence_bound.h
@@ -515,7 +515,14 @@ class SequenceBound {
     ~AsyncCallWithBoundArgsBuilder() {
       // Must use Then() since the method's return type is not void.
       // Should be optimized out if the code is bug-free.
-      CHECK(!this->sequence_bound_);
+      if (std::is_same<ReturnType, void>::value) {
+        if (this->sequence_bound_) {
+          this->sequence_bound_->impl_task_runner_->PostTask(
+              *this->location_, std::move(this->callback_));
+        }
+      } else {
+        CHECK(!this->sequence_bound_);
+      }
     }
 
     template <template <typename> class CallbackType,
@@ -528,34 +535,8 @@ class SequenceBound {
       this->sequence_bound_ = nullptr;
     }
 
-   protected:
-    using AsyncCallWithBoundArgsBuilderBase<
-        ReturnType>::AsyncCallWithBoundArgsBuilderBase;
-
-   private:
-    friend SequenceBound;
-
-    AsyncCallWithBoundArgsBuilder(AsyncCallWithBoundArgsBuilder&&) = default;
-    AsyncCallWithBoundArgsBuilder& operator=(AsyncCallWithBoundArgsBuilder&&) =
-        default;
-  };
-
-  template <>
-  class AsyncCallWithBoundArgsBuilder<void>
-      : public AsyncCallWithBoundArgsBuilderBase<void> {
-   public:
-    // Note: despite being here, this is actually still protected, since it is
-    // protected on the base class.
-    using AsyncCallWithBoundArgsBuilderBase<
-        void>::AsyncCallWithBoundArgsBuilderBase;
-
-    ~AsyncCallWithBoundArgsBuilder() {
-      if (this->sequence_bound_) {
-        this->sequence_bound_->impl_task_runner_->PostTask(
-            *this->location_, std::move(this->callback_));
-      }
-    }
-
+    template <typename RetT = ReturnType,
+              std::enable_if_t<std::is_same<RetT, void>::value>>
     void Then(OnceClosure then_callback) && {
       this->sequence_bound_->PostTaskAndThenHelper(*this->location_,
                                                    std::move(this->callback_),
@@ -563,6 +544,10 @@ class SequenceBound {
       this->sequence_bound_ = nullptr;
     }
 
+   protected:
+    using AsyncCallWithBoundArgsBuilderBase<
+        ReturnType>::AsyncCallWithBoundArgsBuilderBase;
+
    private:
     friend SequenceBound;
 
-- 
2.25.1

