From eaeb5428b70d00ed6c2b43c25d79152219eddf64 Mon Sep 17 00:00:00 2001
From: Jose Dapena Paz <jdapena@igalia.com>
Date: Mon, 22 Jan 2024 19:58:26 +0100
Subject: Revert "Revert^2 "[Fontations-backend] Add COLRv0/v1 support to
 Fontations backend""

This reverts commit 0443e02cdfd37089c70ba505b68f351a40e7b0f8.
---
 gm/BUILD.bazel                           |   2 -
 gm/colrv1.cpp                            |  41 +-
 gm/palette.cpp                           |  40 +-
 src/ports/SkTypeface_fontations.cpp      | 699 +----------------------
 src/ports/SkTypeface_fontations_priv.h   | 103 ----
 src/ports/fontations/src/ffi.rs          | 335 +----------
 src/ports/fontations/src/skpath_bridge.h |  41 --
 7 files changed, 47 insertions(+), 1214 deletions(-)

diff --git a/gm/BUILD.bazel b/gm/BUILD.bazel
index a1ba784329..d0db7c61ed 100644
--- a/gm/BUILD.bazel
+++ b/gm/BUILD.bazel
@@ -11,9 +11,7 @@ filegroup(
     name = "gm_subset",
     srcs = [
         "bitmaprect.cpp",
-        "colrv1.cpp",
         "fontations.cpp",
-        "palette.cpp",
     ],
     visibility = ["//tools/viewer:__pkg__"],
 )
diff --git a/gm/colrv1.cpp b/gm/colrv1.cpp
index e0a463c45b..6e0d1d7112 100644
--- a/gm/colrv1.cpp
+++ b/gm/colrv1.cpp
@@ -10,59 +10,29 @@
 #include "include/core/SkColor.h"
 #include "include/core/SkFont.h"
 #include "include/core/SkFontMetrics.h"
-#include "include/core/SkFontMgr.h"
 #include "include/core/SkGraphics.h"
 #include "include/core/SkPaint.h"
 #include "include/core/SkRefCnt.h"
 #include "include/core/SkScalar.h"
 #include "include/core/SkSize.h"
-#include "include/core/SkStream.h"
 #include "include/core/SkString.h"
 #include "include/core/SkTypeface.h"
 #include "tools/Resources.h"
 #include "tools/ToolUtils.h"
 #include "tools/fonts/FontToolUtils.h"
 
-#include "include/ports/SkTypeface_fontations.h"
-// #include "include/ports/SkFontMgr_empty.h"
-
 #include <string.h>
 #include <initializer_list>
 
 namespace skiagm {
 
-namespace {
-enum TypefaceBackend { UseDefault, UseFontations };
-
-// TODO(b/318667611): Move the explicit instantation to font manager for Fontations.
-#if defined(SK_TYPEFACE_FACTORY_FONTATIONS)
-constexpr auto kBackend = TypefaceBackend::UseFontations;
-#else
-constexpr auto kBackend = TypefaceBackend::UseDefault;
-#endif
-
-template <TypefaceBackend variant> sk_sp<SkTypeface> MakeTypefaceFromResource(const char* resource);
-
-#if defined(SK_TYPEFACE_FACTORY_FONTATIONS)
-template <> sk_sp<SkTypeface> MakeTypefaceFromResource<UseFontations>(const char* resource) {
-    std::unique_ptr<SkStreamAsset> resourceStream(GetResourceAsStream(resource, false));
-    return SkTypeface_Make_Fontations(std::move(resourceStream), SkFontArguments());
-}
-#else
-template <> sk_sp<SkTypeface> MakeTypefaceFromResource<UseDefault>(const char* resource) {
-    return ToolUtils::CreateTypefaceFromResource(resource, 0);
-}
-#endif
-
-}  // namespace
-
 namespace {
 const SkScalar kTextSizes[] = {12, 18, 30, 120};
 const char kTestFontName[] = "fonts/test_glyphs-glyf_colr_1.ttf";
 const char kTestFontNameVariable[] = "fonts/test_glyphs-glyf_colr_1_variable.ttf";
 const SkScalar xWidth = 1200;
 const SkScalar xTranslate = 200;
-}  // namespace
+}
 
 class ColrV1GM : public GM {
 public:
@@ -72,7 +42,10 @@ public:
              SkScalar rotateDeg,
              std::initializer_list<SkFontArguments::VariationPosition::Coordinate>
                      specifiedVariations)
-            : fTestName(testName), fCodepoints(codepoints), fSkewX(skewX), fRotateDeg(rotateDeg) {
+            : fTestName(testName)
+            , fCodepoints(codepoints)
+            , fSkewX(skewX)
+            , fRotateDeg(rotateDeg) {
         fVariationPosition.coordinateCount = specifiedVariations.size();
         fCoordinates = std::make_unique<SkFontArguments::VariationPosition::Coordinate[]>(
                 specifiedVariations.size());
@@ -86,9 +59,9 @@ public:
 protected:
     void onOnceBeforeDraw() override {
         if (fVariationPosition.coordinateCount) {
-            fTypeface = MakeTypefaceFromResource<kBackend>(kTestFontNameVariable);
+            fTypeface = ToolUtils::CreateTypefaceFromResource(kTestFontNameVariable);
         } else {
-            fTypeface = MakeTypefaceFromResource<kBackend>(kTestFontName);
+            fTypeface = ToolUtils::CreateTypefaceFromResource(kTestFontName);
         }
         fVariationSliders = ToolUtils::VariationSliders(fTypeface.get(), fVariationPosition);
     }
diff --git a/gm/palette.cpp b/gm/palette.cpp
index 478f9c07c2..f781839440 100644
--- a/gm/palette.cpp
+++ b/gm/palette.cpp
@@ -23,10 +23,6 @@
 #include "tools/ToolUtils.h"
 #include "tools/fonts/FontToolUtils.h"
 
-#if defined(SK_TYPEFACE_FACTORY_FONTATIONS)
-#include "include/ports/SkTypeface_fontations.h"
-#endif
-
 #include <string.h>
 
 namespace skiagm {
@@ -73,35 +69,6 @@ constexpr SkFontArguments::Palette kOnePaletteOverride{
 constexpr SkFontArguments::Palette kAllPaletteOverride{
         0, kColorOverridesAll, std::size(kColorOverridesAll)};
 
-
-
-enum TypefaceBackend { UseDefault, UseFontations };
-
-// TODO(b/318667611): Move the explicit instantation to font manager for Fontations.
-#if defined(SK_TYPEFACE_FACTORY_FONTATIONS)
-constexpr auto kBackend = TypefaceBackend::UseFontations;
-#else
-constexpr auto kBackend = TypefaceBackend::UseDefault;
-#endif
-
-template <TypefaceBackend variant>
-sk_sp<SkTypeface> MakeTypefaceFromResource(const char* resource, const SkFontArguments& args);
-
-#if defined(SK_TYPEFACE_FACTORY_FONTATIONS)
-template <>
-sk_sp<SkTypeface> MakeTypefaceFromResource<UseFontations>(const char* resource,
-                                                          const SkFontArguments& args) {
-    std::unique_ptr<SkStreamAsset> resourceStream(GetResourceAsStream(resource, false));
-    return SkTypeface_Make_Fontations(std::move(resourceStream), args);
-}
-#else
-template <>
-sk_sp<SkTypeface> MakeTypefaceFromResource<UseDefault>(const char* resource,
-                                                       const SkFontArguments& args) {
-    return ToolUtils::TestFontMgr()->makeFromStream(GetResourceAsStream(resource), args);
-}
-#endif
-
 }  // namespace
 
 class FontPaletteGM : public GM {
@@ -119,13 +86,12 @@ protected:
         SkFontArguments paletteArguments;
         paletteArguments.setPalette(fPalette);
 
-        fTypefaceDefault =
-                MakeTypefaceFromResource<kBackend>(kColrCpalTestFontPath, SkFontArguments());
+        fTypefaceDefault = ToolUtils::CreateTypefaceFromResource(kColrCpalTestFontPath);
         fTypefaceCloned =
                 fTypefaceDefault ? fTypefaceDefault->makeClone(paletteArguments) : nullptr;
 
-        fTypefaceFromStream =
-                MakeTypefaceFromResource<kBackend>(kColrCpalTestFontPath, paletteArguments);
+        fTypefaceFromStream = ToolUtils::TestFontMgr()->makeFromStream(
+                GetResourceAsStream(kColrCpalTestFontPath), paletteArguments);
     }
 
     SkString getName() const override {
diff --git a/src/ports/SkTypeface_fontations.cpp b/src/ports/SkTypeface_fontations.cpp
index 99abdf07b3..f165205c97 100644
--- a/src/ports/SkTypeface_fontations.cpp
+++ b/src/ports/SkTypeface_fontations.cpp
@@ -5,14 +5,11 @@
  * found in the LICENSE file.
  */
 
-#include "include/core/SkBitmap.h"
-#include "include/core/SkCanvas.h"
 #include "include/core/SkData.h"
 #include "include/core/SkFontMetrics.h"
-#include "include/core/SkPictureRecorder.h"
 #include "include/core/SkStream.h"
-#include "include/effects/SkGradientShader.h"
 #include "include/pathops/SkPathOps.h"
+#include "include/ports/SkTypeface_fontations.h"
 #include "src/core/SkFontDescriptor.h"
 #include "src/core/SkFontPriv.h"
 #include "src/ports/SkTypeface_fontations_priv.h"
@@ -21,8 +18,6 @@
 
 namespace {
 
-[[maybe_unused]] static inline const constexpr bool kSkShowTextBlitCoverage = false;
-
 sk_sp<SkData> streamToData(const std::unique_ptr<SkStreamAsset>& font_data) {
     // TODO(drott): From a stream this causes a full read/copy. Make sure
     // we can instantiate this directly from the decompressed buffer that
@@ -60,7 +55,6 @@ rust::Box<fontations_ffi::BridgeNormalizedCoords> make_normalized_coords(
             variationPosition.coordinateCount);
     return resolve_into_normalized_coords(bridgeFontRef, coordinates);
 }
-
 }  // namespace
 
 SK_API sk_sp<SkTypeface> SkTypeface_Make_Fontations(std::unique_ptr<SkStreamAsset> fontData,
@@ -94,7 +88,6 @@ sk_sp<SkTypeface> SkTypeface_Fontations::MakeFromData(sk_sp<SkData> data,
 }
 
 namespace sk_fontations {
-
 // Path sanitization ported from SkFTGeometrySink.
 void PathGeometrySink::going_to(SkPoint point) {
     if (!fStarted) {
@@ -162,7 +155,6 @@ bool AxisWrapper::populate_axis(
 }
 
 size_t AxisWrapper::size() const { return fAxisCount; }
-
 }  // namespace sk_fontations
 
 int SkTypeface_Fontations::onGetUPEM() const {
@@ -250,40 +242,12 @@ public:
                                               ->getBridgeNormalizedCoords())
             , fPalette(static_cast<SkTypeface_Fontations*>(this->getTypeface())->getPalette()) {
         fRec.getSingleMatrix(&fMatrix);
-    }
-
-    // TODO(drott): Add parameter/control for hinting here once that is available from Fontations.
-    bool generateYScalePathForGlyphId(uint16_t glyphId, SkPath* path, float yScale) {
-        sk_fontations::PathGeometrySink pathWrapper;
-        fontations_ffi::BridgeScalerMetrics scalerMetrics;
-
-        if (!fontations_ffi::get_path(fBridgeFontRef,
-                                      glyphId,
-                                      yScale,
-                                      fBridgeNormalizedCoords,
-                                      pathWrapper,
-                                      scalerMetrics)) {
-            return false;
-        }
-        *path = std::move(pathWrapper).into_inner();
-        if (scalerMetrics.has_overlaps) {
-            // See SkScalerContext_FreeType_Base::generateGlyphPath.
-            Simplify(*path, path);
-            AsWinding(*path, path);
-        }
-        return true;
+        this->forceGenerateImageFromPath();
     }
 
 protected:
-    struct ScalerContextBits {
-        using value_type = uint16_t;
-        static const constexpr value_type PATH = 1;
-        static const constexpr value_type COLRv0 = 2;
-        static const constexpr value_type COLRv1 = 3;
-    };
-
     GlyphMetrics generateMetrics(const SkGlyph& glyph, SkArenaAlloc*) override {
-        GlyphMetrics mx(glyph.maskFormat());
+        GlyphMetrics mx(fRec.fMaskFormat);
 
         SkVector scale;
         SkMatrix remainingMatrix;
@@ -296,181 +260,42 @@ protected:
                 fBridgeFontRef, scale.y(), fBridgeNormalizedCoords, glyph.getGlyphID());
         // TODO(drott): y-advance?
         mx.advance = remainingMatrix.mapXY(x_advance, SkFloatToScalar(0.f));
-
-        // The FreeType backend has a big switch here:
-        // Scalable or bitmap, monochromatic or color, subpixel shifting bounds if needed.
-        // For now: check if COLRv1, get clipbox, else -
-        // get bounds from Path.
-        // TODO(drott): Later move bounds retrieval for monochromatic glyphs to retrieving
-        // them from Skrifa scaler, taking hinting into account.
-
-        bool has_colrv1_glyph =
-                fontations_ffi::has_colrv1_glyph(fBridgeFontRef, glyph.getGlyphID());
-        bool has_colrv0_glyph =
-                fontations_ffi::has_colrv0_glyph(fBridgeFontRef, glyph.getGlyphID());
-
-        if (has_colrv1_glyph || has_colrv0_glyph) {
-            mx.extraBits = has_colrv1_glyph ? ScalerContextBits::COLRv1 : ScalerContextBits::COLRv0;
-            mx.maskFormat = SkMask::kARGB32_Format;
-            mx.neverRequestPath = true;
-
-            fontations_ffi::ClipBox clipBox;
-            if (has_colrv1_glyph && fontations_ffi::get_colrv1_clip_box(fBridgeFontRef,
-                                                                        fBridgeNormalizedCoords,
-                                                                        glyph.getGlyphID(),
-                                                                        scale.y(),
-                                                                        clipBox)) {
-                // Flip y.
-                SkRect boundsRect = SkRect::MakeLTRB(
-                        clipBox.x_min, -clipBox.y_max, clipBox.x_max, -clipBox.y_min);
-
-                if (!remainingMatrix.isIdentity()) {
-                    SkPath boundsPath = SkPath::Rect(boundsRect);
-                    boundsPath.transform(remainingMatrix);
-                    boundsRect = boundsPath.getBounds();
-                }
-
-                boundsRect.roundOut(&mx.bounds);
-
-            } else {
-                uint16_t upem = fontations_ffi::units_per_em_or_zero(fBridgeFontRef);
-                if (upem == 0) {
-                    mx.bounds = SkRect::MakeEmpty();
-                } else {
-                    SkMatrix fullTransform;
-                    fRec.getSingleMatrix(&fullTransform);
-                    fullTransform.preScale(1.f / upem, 1.f / upem);
-
-                    sk_fontations::BoundsPainter boundsPainter(*this, fullTransform, upem);
-                    bool result = fontations_ffi::draw_colr_glyph(fBridgeFontRef,
-                                                                  fBridgeNormalizedCoords,
-                                                                  glyph.getGlyphID(),
-                                                                  boundsPainter);
-                    if (result) {
-                        boundsPainter.getBoundingBox().roundOut(&mx.bounds);
-                    } else {
-                        mx.bounds = SkRect::MakeEmpty();
-                    }
-                }
-            }
-        } else {
-            // TODO: Retrieve from read_fonts and Skrifa - TrueType bbox or from path with
-            // hinting?
-            mx.extraBits = ScalerContextBits::PATH;
-            mx.computeFromPath = true;
-        }
+        mx.computeFromPath = true;
         return mx;
     }
 
-    void generateImage(const SkGlyph& glyph, void* imageBuffer) override {
-        ScalerContextBits::value_type format = glyph.extraBits();
-        if (format == ScalerContextBits::PATH) {
-            const SkPath* devPath = glyph.path();
-            SkASSERT_RELEASE(devPath);
-            SkMaskBuilder mask(static_cast<uint8_t*>(imageBuffer),
-                               glyph.iRect(),
-                               glyph.rowBytes(),
-                               glyph.maskFormat());
-            SkASSERT(SkMask::kARGB32_Format != mask.fFormat);
-            const bool doBGR = SkToBool(fRec.fFlags & SkScalerContext::kLCD_BGROrder_Flag);
-            const bool doVert = SkToBool(fRec.fFlags & SkScalerContext::kLCD_Vertical_Flag);
-            const bool a8LCD = SkToBool(fRec.fFlags & SkScalerContext::kGenA8FromLCD_Flag);
-            const bool hairline = glyph.pathIsHairline();
-            GenerateImageFromPath(mask, *devPath, fPreBlend, doBGR, doVert, a8LCD, hairline);
-
-        } else if (format == ScalerContextBits::COLRv1 || format == ScalerContextBits::COLRv0) {
-            SkASSERT(glyph.maskFormat() == SkMask::kARGB32_Format);
-            SkBitmap dstBitmap;
-            dstBitmap.setInfo(
-                    SkImageInfo::Make(
-                            glyph.width(), glyph.height(), kN32_SkColorType, kPremul_SkAlphaType),
-                    glyph.rowBytes());
-            dstBitmap.setPixels(imageBuffer);
-
-            SkCanvas canvas(dstBitmap);
-            if constexpr (kSkShowTextBlitCoverage) {
-                canvas.clear(0x33FF0000);
-            } else {
-                canvas.clear(SK_ColorTRANSPARENT);
-            }
-            canvas.translate(-glyph.left(), -glyph.top());
-
-            drawCOLRGlyph(glyph, fRec.fForegroundColor, &canvas);
-        } else {
-            SK_ABORT("Bad format");
-        }
+    void generateImage(const SkGlyph&, void*) override {
+        SK_ABORT("Should have generated from path.");
     }
 
     bool generatePath(const SkGlyph& glyph, SkPath* path) override {
-        SkASSERT(glyph.extraBits() != ScalerContextBits::COLRv1);
-        SkASSERT(glyph.extraBits() != ScalerContextBits::COLRv0);
-
         SkVector scale;
         SkMatrix remainingMatrix;
         if (!fRec.computeMatrices(
                     SkScalerContextRec::PreMatrixScale::kVertical, &scale, &remainingMatrix)) {
             return false;
         }
-        bool result = generateYScalePathForGlyphId(glyph.getGlyphID(), path, scale.y());
-        if (!result) {
+        sk_fontations::PathGeometrySink pathWrapper;
+        fontations_ffi::BridgeScalerMetrics scalerMetrics;
+
+        if (!fontations_ffi::get_path(fBridgeFontRef,
+                                      glyph.getGlyphID(),
+                                      scale.y(),
+                                      fBridgeNormalizedCoords,
+                                      pathWrapper,
+                                      scalerMetrics)) {
             return false;
         }
-
+        *path = std::move(pathWrapper).into_inner();
+        if (scalerMetrics.has_overlaps) {
+            // See SkScalerContext_FreeType_Base::generateGlyphPath.
+            Simplify(*path, path);
+            AsWinding(*path, path);
+        }
         *path = path->makeTransform(remainingMatrix);
         return true;
     }
 
-    bool drawCOLRGlyph(const SkGlyph& glyph, SkColor foregroundColor, SkCanvas* canvas) {
-        uint16_t upem = fontations_ffi::units_per_em_or_zero(fBridgeFontRef);
-        if (upem == 0) {
-            return false;
-        }
-
-        SkMatrix scalerMatrix;
-        fRec.getSingleMatrix(&scalerMatrix);
-        SkAutoCanvasRestore autoRestore(canvas, true /* doSave */);
-
-        // Scale down so that COLR operations can happen in glyph coordinates.
-        SkMatrix upemToPpem = SkMatrix::Scale(1.f / upem, 1.f / upem);
-        scalerMatrix.preConcat(upemToPpem);
-        canvas->concat(scalerMatrix);
-        SkPaint defaultPaint;
-        defaultPaint.setColor(SK_ColorRED);
-        sk_fontations::ColorPainter colorPainter(*this, *canvas, fPalette, foregroundColor, upem);
-        bool result = fontations_ffi::draw_colr_glyph(
-                fBridgeFontRef, fBridgeNormalizedCoords, glyph.getGlyphID(), colorPainter);
-        return result;
-    }
-
-    sk_sp<SkDrawable> generateDrawable(const SkGlyph& glyph) override {
-        struct GlyphDrawable : public SkDrawable {
-            SkFontationsScalerContext* fSelf;
-            SkGlyph fGlyph;
-            GlyphDrawable(SkFontationsScalerContext* self, const SkGlyph& glyph)
-                    : fSelf(self), fGlyph(glyph) {}
-            SkRect onGetBounds() override { return fGlyph.rect(); }
-            size_t onApproximateBytesUsed() override { return sizeof(GlyphDrawable); }
-            void maybeShowTextBlitCoverage(SkCanvas* canvas) {
-                if constexpr (kSkShowTextBlitCoverage) {
-                    SkPaint paint;
-                    paint.setColor(0x3300FF00);
-                    paint.setStyle(SkPaint::kFill_Style);
-                    canvas->drawRect(this->onGetBounds(), paint);
-                }
-            }
-        };
-        struct ColrGlyphDrawable : public GlyphDrawable {
-            using GlyphDrawable::GlyphDrawable;
-            void onDraw(SkCanvas* canvas) override {
-                this->maybeShowTextBlitCoverage(canvas);
-                fSelf->drawCOLRGlyph(fGlyph, fSelf->fRec.fForegroundColor, canvas);
-            }
-        };
-        ScalerContextBits::value_type format = glyph.extraBits();
-        SkASSERT(format == ScalerContextBits::COLRv1 || format == ScalerContextBits::COLRv0);
-        return sk_sp<SkDrawable>(new ColrGlyphDrawable(this, glyph));
-    }
-
     void generateFontMetrics(SkFontMetrics* out_metrics) override {
         fontations_ffi::Metrics metrics = fontations_ffi::get_skia_metrics(
                 fBridgeFontRef, fMatrix.getScaleY(), fBridgeNormalizedCoords);
@@ -495,7 +320,6 @@ private:
     const fontations_ffi::BridgeFontRef& fBridgeFontRef;
     const fontations_ffi::BridgeNormalizedCoords& fBridgeNormalizedCoords;
     const SkSpan<SkColor> fPalette;
-    friend class sk_fontations::ColorPainter;
 };
 
 std::unique_ptr<SkStreamAsset> SkTypeface_Fontations::onOpenStream(int* ttcIndex) const {
@@ -538,7 +362,7 @@ size_t SkTypeface_Fontations::onGetTableData(SkFontTableTag tag,
 int SkTypeface_Fontations::onGetTableTags(SkFontTableTag tags[]) const {
     uint16_t numTables = fontations_ffi::table_tags(*fBridgeFontRef, rust::Slice<uint32_t>());
     if (!tags) {
-        return numTables;
+      return numTables;
     }
     rust::Slice<uint32_t> copyToTags(tags, numTables);
     return fontations_ffi::table_tags(*fBridgeFontRef, copyToTags);
@@ -548,9 +372,9 @@ int SkTypeface_Fontations::onGetVariationDesignPosition(
         SkFontArguments::VariationPosition::Coordinate coordinates[], int coordinateCount) const {
     rust::Slice<fontations_ffi::SkiaDesignCoordinate> copyToCoordinates;
     if (coordinates) {
-        copyToCoordinates = rust::Slice<fontations_ffi::SkiaDesignCoordinate>(
-                reinterpret_cast<fontations_ffi::SkiaDesignCoordinate*>(coordinates),
-                coordinateCount);
+      copyToCoordinates = rust::Slice<fontations_ffi::SkiaDesignCoordinate>(
+              reinterpret_cast<fontations_ffi::SkiaDesignCoordinate*>(coordinates),
+              coordinateCount);
     }
     return fontations_ffi::variation_position(*fBridgeNormalizedCoords, copyToCoordinates);
 }
@@ -560,476 +384,3 @@ int SkTypeface_Fontations::onGetVariationDesignParameters(
     sk_fontations::AxisWrapper axisWrapper(parameters, parameterCount);
     return fontations_ffi::populate_axes(*fBridgeFontRef, axisWrapper);
 }
-
-namespace sk_fontations {
-
-namespace {
-
-const uint16_t kForegroundColorPaletteIndex = 0xFFFF;
-
-void populateStopsAndColors(std::vector<SkScalar>& dest_stops,
-                            std::vector<SkColor4f>& dest_colors,
-                            const SkSpan<SkColor>& palette,
-                            SkColor foregroundColor,
-                            fontations_ffi::BridgeColorStops& color_stops) {
-    SkASSERT(dest_stops.size() == 0);
-    SkASSERT(dest_colors.size() == 0);
-    size_t num_color_stops = fontations_ffi::num_color_stops(color_stops);
-    dest_stops.reserve(num_color_stops);
-    dest_colors.reserve(num_color_stops);
-
-    fontations_ffi::ColorStop color_stop;
-    while (fontations_ffi::next_color_stop(color_stops, color_stop)) {
-        dest_stops.push_back(color_stop.stop);
-        SkColor4f dest_color;
-        if (color_stop.palette_index == kForegroundColorPaletteIndex) {
-            dest_color = SkColor4f::FromColor(foregroundColor);
-        } else {
-            dest_color = SkColor4f::FromColor(palette[color_stop.palette_index]);
-        }
-        dest_color.fA *= color_stop.alpha;
-        dest_colors.push_back(dest_color);
-    }
-}
-
-SkColor4f lerpSkColor(SkColor4f c0, SkColor4f c1, float t) {
-    // Due to the floating point calculation in the caller, when interpolating between very
-    // narrow stops, we may get values outside the interpolation range, guard against these.
-    if (t < 0) {
-        return c0;
-    }
-    if (t > 1) {
-        return c1;
-    }
-
-    const auto c0_4f = skvx::float4::Load(c0.vec());
-    const auto c1_4f = skvx::float4::Load(c1.vec());
-    const auto c_4f = c0_4f + (c1_4f - c0_4f) * t;
-
-    SkColor4f l;
-    c_4f.store(l.vec());
-    return l;
-}
-
-enum TruncateStops { TruncateStart, TruncateEnd };
-
-// Truncate a vector of color stops at a previously computed stop position and insert at that
-// position the color interpolated between the surrounding stops.
-void truncateToStopInterpolating(SkScalar zeroRadiusStop,
-                                 std::vector<SkColor4f>& colors,
-                                 std::vector<SkScalar>& stops,
-                                 TruncateStops truncateStops) {
-    if (stops.size() <= 1u || zeroRadiusStop < stops.front() || stops.back() < zeroRadiusStop) {
-        return;
-    }
-
-    size_t afterIndex =
-            (truncateStops == TruncateStart)
-                    ? std::lower_bound(stops.begin(), stops.end(), zeroRadiusStop) - stops.begin()
-                    : std::upper_bound(stops.begin(), stops.end(), zeroRadiusStop) - stops.begin();
-
-    const float t =
-            (zeroRadiusStop - stops[afterIndex - 1]) / (stops[afterIndex] - stops[afterIndex - 1]);
-    SkColor4f lerpColor = lerpSkColor(colors[afterIndex - 1], colors[afterIndex], t);
-
-    if (truncateStops == TruncateStart) {
-        stops.erase(stops.begin(), stops.begin() + afterIndex);
-        colors.erase(colors.begin(), colors.begin() + afterIndex);
-        stops.insert(stops.begin(), 0);
-        colors.insert(colors.begin(), lerpColor);
-    } else {
-        stops.erase(stops.begin() + afterIndex, stops.end());
-        colors.erase(colors.begin() + afterIndex, colors.end());
-        stops.insert(stops.end(), 1);
-        colors.insert(colors.end(), lerpColor);
-    }
-}
-
-// https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-32-paintcomposite
-inline SkBlendMode ToSkBlendMode(uint16_t colrV1CompositeMode) {
-    switch (colrV1CompositeMode) {
-        case 0:
-            return SkBlendMode::kClear;
-        case 1:
-            return SkBlendMode::kSrc;
-        case 2:
-            return SkBlendMode::kDst;
-        case 3:
-            return SkBlendMode::kSrcOver;
-        case 4:
-            return SkBlendMode::kDstOver;
-        case 5:
-            return SkBlendMode::kSrcIn;
-        case 6:
-            return SkBlendMode::kDstIn;
-        case 7:
-            return SkBlendMode::kSrcOut;
-        case 8:
-            return SkBlendMode::kDstOut;
-        case 9:
-            return SkBlendMode::kSrcATop;
-        case 10:
-            return SkBlendMode::kDstATop;
-        case 11:
-            return SkBlendMode::kXor;
-        case 12:
-            return SkBlendMode::kPlus;
-        case 13:
-            return SkBlendMode::kScreen;
-        case 14:
-            return SkBlendMode::kOverlay;
-        case 15:
-            return SkBlendMode::kDarken;
-        case 16:
-            return SkBlendMode::kLighten;
-        case 17:
-            return SkBlendMode::kColorDodge;
-        case 18:
-            return SkBlendMode::kColorBurn;
-        case 19:
-            return SkBlendMode::kHardLight;
-        case 20:
-            return SkBlendMode::kSoftLight;
-        case 21:
-            return SkBlendMode::kDifference;
-        case 22:
-            return SkBlendMode::kExclusion;
-        case 23:
-            return SkBlendMode::kMultiply;
-        case 24:
-            return SkBlendMode::kHue;
-        case 25:
-            return SkBlendMode::kSaturation;
-        case 26:
-            return SkBlendMode::kColor;
-        case 27:
-            return SkBlendMode::kLuminosity;
-        default:
-            return SkBlendMode::kDst;
-    }
-}
-
-inline SkTileMode ToSkTileMode(uint8_t extendMode) {
-    switch (extendMode) {
-        case 1:
-            return SkTileMode::kRepeat;
-        case 2:
-            return SkTileMode::kMirror;
-        default:
-            return SkTileMode::kClamp;
-    }
-}
-}  // namespace
-
-ColorPainter::ColorPainter(SkFontationsScalerContext& scaler_context,
-                           SkCanvas& canvas,
-                           SkSpan<SkColor> palette,
-                           SkColor foregroundColor,
-                           uint16_t upem)
-        : fScalerContext(scaler_context)
-        , fCanvas(canvas)
-        , fPalette(palette)
-        , fForegroundColor(foregroundColor)
-        , fUpem(upem) {}
-
-void ColorPainter::push_transform(float xx, float xy, float yx, float yy, float dx, float dy) {
-    fCanvas.save();
-    SkMatrix transform = SkMatrix::MakeAll(xx, -xy, dx, -yx, yy, -dy, 0.f, 0.f, 1.0f);
-    fCanvas.concat(transform);
-}
-
-void ColorPainter::pop_transform() { fCanvas.restore(); }
-
-void ColorPainter::push_clip_glyph(uint16_t glyph_id) {
-    fCanvas.save();
-    SkPath path;
-    fScalerContext.generateYScalePathForGlyphId(glyph_id, &path, fUpem);
-    fCanvas.clipPath(path, true /* doAntialias */);
-}
-
-void ColorPainter::push_clip_rectangle(float x_min, float y_min, float x_max, float y_max) {
-    fCanvas.save();
-    SkRect clipRect = SkRect::MakeLTRB(x_min, -y_min, x_max, -y_max);
-    fCanvas.clipRect(clipRect, true);
-}
-
-void ColorPainter::pop_clip() { fCanvas.restore(); }
-
-void ColorPainter::fill_solid(uint16_t palette_index, float alpha) {
-    SkPaint paint;
-    SkColor4f color;
-    if (palette_index == kForegroundColorPaletteIndex) {
-        color = SkColor4f::FromColor(fForegroundColor);
-    } else {
-        color = SkColor4f::FromColor(fPalette[palette_index]);
-    }
-    color.fA *= alpha;
-    paint.setShader(nullptr);
-    paint.setColor(color);
-    fCanvas.drawPaint(paint);
-}
-
-void ColorPainter::fill_linear(float x0,
-                               float y0,
-                               float x1,
-                               float y1,
-                               fontations_ffi::BridgeColorStops& bridge_stops,
-                               uint8_t extend_mode) {
-    SkPaint paint;
-
-    std::vector<SkScalar> stops;
-    std::vector<SkColor4f> colors;
-
-    populateStopsAndColors(stops, colors, fPalette, fForegroundColor, bridge_stops);
-
-    if (stops.size() == 1) {
-        paint.setColor(colors[0]);
-        return;
-    }
-
-    SkPoint linePositions[2] = {SkPoint::Make(SkFloatToScalar(x0), -SkFloatToScalar(y0)),
-                                SkPoint::Make(SkFloatToScalar(x1), -SkFloatToScalar(y1))};
-    SkTileMode tileMode = ToSkTileMode(extend_mode);
-
-    sk_sp<SkShader> shader(SkGradientShader::MakeLinear(
-            linePositions,
-            colors.data(),
-            SkColorSpace::MakeSRGB(),
-            stops.data(),
-            stops.size(),
-            tileMode,
-            SkGradientShader::Interpolation{SkGradientShader::Interpolation::InPremul::kNo,
-                                            SkGradientShader::Interpolation::ColorSpace::kSRGB,
-                                            SkGradientShader::Interpolation::HueMethod::kShorter},
-            nullptr));
-
-    SkASSERT(shader);
-    // An opaque color is needed to ensure the gradient is not modulated by alpha.
-    paint.setColor(SK_ColorBLACK);
-    paint.setShader(shader);
-    fCanvas.drawPaint(paint);
-}
-
-void ColorPainter::fill_radial(float x0,
-                               float y0,
-                               float startRadius,
-                               float x1,
-                               float y1,
-                               float endRadius,
-                               fontations_ffi::BridgeColorStops& bridge_stops,
-                               uint8_t extend_mode) {
-    SkPaint paint;
-
-    SkPoint start = SkPoint::Make(x0, -y0);
-    SkPoint end = SkPoint::Make(x1, -y1);
-
-    std::vector<SkScalar> stops;
-    std::vector<SkColor4f> colors;
-
-    populateStopsAndColors(stops, colors, fPalette, fForegroundColor, bridge_stops);
-
-    // Draw single color if there's only one stop.
-    if (stops.size() == 1) {
-        paint.setColor(colors[0]);
-        fCanvas.drawPaint(paint);
-        return;
-    }
-
-    SkTileMode tileMode = ToSkTileMode(extend_mode);
-
-    // For negative radii, interpolation is needed to prepare parameters suitable
-    // for invoking the shader. Implementation below as resolution discussed in
-    // https://github.com/googlefonts/colr-gradients-spec/issues/367.
-    // Truncate to manually interpolated color for tile mode clamp, otherwise
-    // calculate positive projected circles.
-    if (startRadius < 0 || endRadius < 0) {
-        if (startRadius == endRadius && startRadius < 0) {
-            paint.setColor(SK_ColorTRANSPARENT);
-            // return true;
-            return;
-        }
-
-        if (tileMode == SkTileMode::kClamp) {
-            SkVector startToEnd = end - start;
-            SkScalar radiusDiff = endRadius - startRadius;
-            SkScalar zeroRadiusStop = 0.f;
-            TruncateStops truncateSide = TruncateStart;
-            if (startRadius < 0) {
-                truncateSide = TruncateStart;
-
-                // Compute color stop position where radius is = 0.  After the scaling
-                // of stop positions to the normal 0,1 range that we have done above,
-                // the size of the radius as a function of the color stops is: r(x) = r0
-                // + x*(r1-r0) Solving this function for r(x) = 0, we get: x = -r0 /
-                // (r1-r0)
-                zeroRadiusStop = -startRadius / (endRadius - startRadius);
-                startRadius = 0.f;
-                SkVector startEndDiff = end - start;
-                startEndDiff.scale(zeroRadiusStop);
-                start = start + startEndDiff;
-            }
-
-            if (endRadius < 0) {
-                truncateSide = TruncateEnd;
-                zeroRadiusStop = -startRadius / (endRadius - startRadius);
-                endRadius = 0.f;
-                SkVector startEndDiff = end - start;
-                startEndDiff.scale(1 - zeroRadiusStop);
-                end = end - startEndDiff;
-            }
-
-            if (!(startRadius == 0 && endRadius == 0)) {
-                truncateToStopInterpolating(zeroRadiusStop, colors, stops, truncateSide);
-            } else {
-                // If both radii have become negative and where clamped to 0, we need to
-                // produce a single color cone, otherwise the shader colors the whole
-                // plane in a single color when two radii are specified as 0.
-                if (radiusDiff > 0) {
-                    end = start + startToEnd;
-                    endRadius = radiusDiff;
-                    colors.erase(colors.begin(), colors.end() - 1);
-                    stops.erase(stops.begin(), stops.end() - 1);
-                } else {
-                    start -= startToEnd;
-                    startRadius = -radiusDiff;
-                    colors.erase(colors.begin() + 1, colors.end());
-                    stops.erase(stops.begin() + 1, stops.end());
-                }
-            }
-        } else {
-            if (startRadius < 0 || endRadius < 0) {
-                auto roundIntegerMultiple = [](SkScalar factorZeroCrossing, SkTileMode tileMode) {
-                    int roundedMultiple = factorZeroCrossing > 0 ? ceilf(factorZeroCrossing)
-                                                                 : floorf(factorZeroCrossing) - 1;
-                    if (tileMode == SkTileMode::kMirror && roundedMultiple % 2 != 0) {
-                        roundedMultiple += roundedMultiple < 0 ? -1 : 1;
-                    }
-                    return roundedMultiple;
-                };
-
-                SkVector startToEnd = end - start;
-                SkScalar radiusDiff = endRadius - startRadius;
-                SkScalar factorZeroCrossing = (startRadius / (startRadius - endRadius));
-                bool inRange = 0.f <= factorZeroCrossing && factorZeroCrossing <= 1.0f;
-                SkScalar direction = inRange && radiusDiff < 0 ? -1.0f : 1.0f;
-                SkScalar circleProjectionFactor =
-                        roundIntegerMultiple(factorZeroCrossing * direction, tileMode);
-                startToEnd.scale(circleProjectionFactor);
-                startRadius += circleProjectionFactor * radiusDiff;
-                endRadius += circleProjectionFactor * radiusDiff;
-                start += startToEnd;
-                end += startToEnd;
-            }
-        }
-    }
-
-    // An opaque color is needed to ensure the gradient is not modulated by alpha.
-    paint.setColor(SK_ColorBLACK);
-
-    paint.setShader(SkGradientShader::MakeTwoPointConical(
-            start,
-            startRadius,
-            end,
-            endRadius,
-            colors.data(),
-            SkColorSpace::MakeSRGB(),
-            stops.data(),
-            stops.size(),
-            tileMode,
-            SkGradientShader::Interpolation{SkGradientShader::Interpolation::InPremul::kNo,
-                                            SkGradientShader::Interpolation::ColorSpace::kSRGB,
-                                            SkGradientShader::Interpolation::HueMethod::kShorter},
-            nullptr));
-
-    fCanvas.drawPaint(paint);
-}
-
-void ColorPainter::fill_sweep(float x0,
-                              float y0,
-                              float startAngle,
-                              float endAngle,
-                              fontations_ffi::BridgeColorStops& bridge_stops,
-                              uint8_t extend_mode) {
-    SkPaint paint;
-
-    SkPoint center = SkPoint::Make(x0, -y0);
-
-    std::vector<SkScalar> stops;
-    std::vector<SkColor4f> colors;
-
-    populateStopsAndColors(stops, colors, fPalette, fForegroundColor, bridge_stops);
-
-    if (stops.size() == 1) {
-        paint.setColor(colors[0]);
-        fCanvas.drawPaint(paint);
-        return;
-    }
-
-    // An opaque color is needed to ensure the gradient is not modulated by alpha.
-    paint.setColor(SK_ColorBLACK);
-    SkTileMode tileMode = ToSkTileMode(extend_mode);
-
-    paint.setColor(SK_ColorBLACK);
-    paint.setShader(SkGradientShader::MakeSweep(
-            center.x(),
-            center.y(),
-            colors.data(),
-            SkColorSpace::MakeSRGB(),
-            stops.data(),
-            stops.size(),
-            tileMode,
-            startAngle,
-            endAngle,
-            SkGradientShader::Interpolation{SkGradientShader::Interpolation::InPremul::kNo,
-                                            SkGradientShader::Interpolation::ColorSpace::kSRGB,
-                                            SkGradientShader::Interpolation::HueMethod::kShorter},
-            nullptr));
-
-    fCanvas.drawPaint(paint);
-}
-
-void ColorPainter::push_layer(uint8_t compositeMode) {
-    SkPaint paint;
-    paint.setBlendMode(ToSkBlendMode(compositeMode));
-    fCanvas.saveLayer(nullptr, &paint);
-}
-
-void ColorPainter::pop_layer() { fCanvas.restore(); }
-
-BoundsPainter::BoundsPainter(SkFontationsScalerContext& scaler_context,
-                             SkMatrix initialTransfom,
-                             uint16_t upem)
-        : fScalerContext(scaler_context)
-        , fCurrentTransform(initialTransfom)
-        , fUpem(upem)
-        , fBounds(SkRect::MakeEmpty()) {}
-
-SkRect BoundsPainter::getBoundingBox() { return fBounds; }
-
-// fontations_ffi::ColorPainter interface.
-void BoundsPainter::push_transform(float xx, float xy, float yx, float yy, float dx, float dy) {
-    SkMatrix transform = SkMatrix::MakeAll(xx, -xy, dx, -yx, yy, -dy, 0.f, 0.f, 1.0f);
-    fCurrentTransform.preConcat(transform);
-    bool invertResult = transform.invert(&fStackTopTransformInverse);
-    SkASSERT(invertResult);
-}
-void BoundsPainter::pop_transform() {
-    fCurrentTransform.preConcat(fStackTopTransformInverse);
-    fStackTopTransformInverse = SkMatrix();
-}
-
-void BoundsPainter::push_clip_glyph(uint16_t glyph_id) {
-    SkPath path;
-    fScalerContext.generateYScalePathForGlyphId(glyph_id, &path, fUpem);
-    path.transform(fCurrentTransform);
-    fBounds.join(path.getBounds());
-}
-
-void BoundsPainter::push_clip_rectangle(float x_min, float y_min, float x_max, float y_max) {
-    SkRect clipRect = SkRect::MakeLTRB(x_min, -y_min, x_max, -y_max);
-    SkPath rectPath = SkPath::Rect(clipRect);
-    rectPath.transform(fCurrentTransform);
-    fBounds.join(rectPath.getBounds());
-}
-
-}  // namespace sk_fontations
diff --git a/src/ports/SkTypeface_fontations_priv.h b/src/ports/SkTypeface_fontations_priv.h
index 2d248b2426..e2ff97f6e2 100644
--- a/src/ports/SkTypeface_fontations_priv.h
+++ b/src/ports/SkTypeface_fontations_priv.h
@@ -20,7 +20,6 @@
 #include <memory>
 
 class SkStreamAsset;
-class SkFontationsScalerContext;
 
 namespace sk_fontations {
 
@@ -62,108 +61,6 @@ private:
     size_t fAxisCount;
 };
 
-class ColorPainter : public fontations_ffi::ColorPainterWrapper {
-public:
-    ColorPainter() = delete;
-    ColorPainter(SkFontationsScalerContext& scaler_context,
-                 SkCanvas& canvas,
-                 SkSpan<SkColor> palette,
-                 SkColor foregroundColor,
-                 uint16_t upem);
-
-    // fontations_ffi::ColorPainter interface.
-    virtual void push_transform(
-            float xx, float xy, float yx, float yy, float dx, float dy) override;
-    virtual void pop_transform() override;
-    virtual void push_clip_glyph(uint16_t glyph_id) override;
-    virtual void push_clip_rectangle(float x_min, float y_min, float x_max, float y_max) override;
-    virtual void pop_clip() override;
-
-    // Paint*Gradient equivalents:
-    virtual void fill_solid(uint16_t palette_index, float alpha) override;
-    virtual void fill_radial(float x0,
-                             float y0,
-                             float r0,
-                             float x1,
-                             float y1,
-                             float r1,
-                             fontations_ffi::BridgeColorStops&,
-                             uint8_t extend_mode) override;
-    virtual void fill_linear(float x0,
-                             float y0,
-                             float x1,
-                             float y1,
-                             fontations_ffi::BridgeColorStops&,
-                             uint8_t extend_mode) override;
-    virtual void fill_sweep(float x0,
-                            float y0,
-                            float startAngle,
-                            float endAngle,
-                            fontations_ffi::BridgeColorStops&,
-                            uint8_t extend_mode) override;
-
-    // compositeMode arg matches composite mode values from the OpenType COLR table spec.
-    virtual void push_layer(uint8_t compositeMode) override;
-    virtual void pop_layer() override;
-
-private:
-    SkFontationsScalerContext& fScalerContext;
-    SkCanvas& fCanvas;
-    SkSpan<SkColor> fPalette;
-    SkColor fForegroundColor;
-    uint16_t fUpem;
-};
-
-/** Tracks transforms and clips to compute a bounding box without drawing pixels. */
-class BoundsPainter : public fontations_ffi::ColorPainterWrapper {
-public:
-    BoundsPainter() = delete;
-    BoundsPainter(SkFontationsScalerContext& scaler_context,
-                  SkMatrix initialTransfom,
-                  uint16_t upem);
-
-    SkRect getBoundingBox();
-
-    // fontations_ffi::ColorPainter interface.
-    virtual void push_transform(
-            float xx, float xy, float yx, float yy, float dx, float dy) override;
-    virtual void pop_transform() override;
-    virtual void push_clip_glyph(uint16_t glyph_id) override;
-    virtual void push_clip_rectangle(float x_min, float y_min, float x_max, float y_max) override;
-    virtual void pop_clip() override {}
-
-    // Paint*Gradient equivalents:
-    virtual void fill_solid(uint16_t palette_index, float alpha) override {}
-    virtual void fill_radial(float,
-                             float,
-                             float,
-                             float,
-                             float,
-                             float,
-                             fontations_ffi::BridgeColorStops& stops,
-                             uint8_t) override {}
-    virtual void fill_linear(
-            float, float, float, float, fontations_ffi::BridgeColorStops& stops, uint8_t) override {
-    }
-    virtual void fill_sweep(float x0,
-                            float y0,
-                            float startAngle,
-                            float endAngle,
-                            fontations_ffi::BridgeColorStops& stops,
-                            uint8_t extend_mode) override {}
-
-    virtual void push_layer(uint8_t) override {}
-    virtual void pop_layer() override {}
-
-private:
-    SkFontationsScalerContext& fScalerContext;
-    SkMatrix fCurrentTransform;
-    SkMatrix fStackTopTransformInverse;
-
-    uint16_t fUpem;
-    SkRect fBounds;
-};
-
 }  // namespace sk_fontations
 
 /** SkTypeface implementation based on Google Fonts Fontations Rust libraries. */
diff --git a/src/ports/fontations/src/ffi.rs b/src/ports/fontations/src/ffi.rs
index 180ab2b015..ac8e29b0da 100644
--- a/src/ports/fontations/src/ffi.rs
+++ b/src/ports/fontations/src/ffi.rs
@@ -1,10 +1,10 @@
 // Copyright 2023 Google LLC
 // Use of this source code is governed by a BSD-style license that can be found
 // in the LICENSE file.
-use font_types::{BoundingBox, GlyphId, Pen};
-use read_fonts::{tables::colr::CompositeMode, FileRef, FontRef, ReadError, TableProvider};
+use cxx;
+use font_types::{GlyphId, Pen};
+use read_fonts::{FileRef, FontRef, ReadError, TableProvider};
 use skrifa::{
-    color::{Brush, ColorGlyphFormat, ColorPainter, Transform},
     instance::{Location, Size},
     metrics::{GlyphMetrics, Metrics},
     outline::DrawSettings,
@@ -14,9 +14,7 @@ use skrifa::{
 };
 use std::pin::Pin;
 
-use crate::ffi::{
-    AxisWrapper, BridgeScalerMetrics, ColorPainterWrapper, ColorStop, PaletteOverride, PathWrapper,
-};
+use crate::ffi::{AxisWrapper, BridgeScalerMetrics, PaletteOverride, PathWrapper};
 
 fn lookup_glyph_or_zero(font_ref: &BridgeFontRef, codepoint: u32) -> u16 {
     font_ref
@@ -61,132 +59,6 @@ impl<'a> Pen for PathWrapperPen<'a> {
     }
 }
 
-struct ColorPainterImpl<'a> {
-    color_painter_wrapper: Pin<&'a mut ffi::ColorPainterWrapper>,
-}
-
-impl<'a> ColorPainter for ColorPainterImpl<'a> {
-    fn push_transform(&mut self, transform: Transform) {
-        self.color_painter_wrapper.as_mut().push_transform(
-            transform.xx,
-            transform.xy,
-            transform.yx,
-            transform.yy,
-            transform.dx,
-            transform.dy,
-        );
-    }
-
-    fn pop_transform(&mut self) {
-        self.color_painter_wrapper.as_mut().pop_transform();
-    }
-
-    fn push_clip_glyph(&mut self, glyph: GlyphId) {
-        self.color_painter_wrapper
-            .as_mut()
-            .push_clip_glyph(glyph.to_u16());
-    }
-
-    fn push_clip_box(&mut self, clip_box: BoundingBox<f32>) {
-        self.color_painter_wrapper.as_mut().push_clip_rectangle(
-            clip_box.x_min,
-            clip_box.y_min,
-            clip_box.x_max,
-            clip_box.y_max,
-        );
-    }
-
-    fn pop_clip(&mut self) {
-        self.color_painter_wrapper.as_mut().pop_clip();
-    }
-
-    fn fill(&mut self, fill_type: Brush) {
-        let color_painter = self.color_painter_wrapper.as_mut();
-        match fill_type {
-            Brush::Solid {
-                palette_index,
-                alpha,
-            } => {
-                color_painter.fill_solid(palette_index, alpha);
-            }
-
-            Brush::LinearGradient {
-                p0,
-                p1,
-                color_stops,
-                extend,
-            } => {
-                let mut bridge_color_stops = BridgeColorStops {
-                    stops_iterator: Box::new(color_stops.iter()),
-                    num_stops: color_stops.len(),
-                };
-                color_painter.fill_linear(
-                    p0.x,
-                    p0.y,
-                    p1.x,
-                    p1.y,
-                    &mut bridge_color_stops,
-                    extend as u8,
-                );
-            }
-            Brush::RadialGradient {
-                c0,
-                r0,
-                c1,
-                r1,
-                color_stops,
-                extend,
-            } => {
-                let mut bridge_color_stops = BridgeColorStops {
-                    stops_iterator: Box::new(color_stops.iter()),
-                    num_stops: color_stops.len(),
-                };
-                color_painter.fill_radial(
-                    c0.x,
-                    c0.y,
-                    r0,
-                    c1.x,
-                    c1.y,
-                    r1,
-                    &mut bridge_color_stops,
-                    extend as u8,
-                );
-            }
-            Brush::SweepGradient {
-                c0,
-                start_angle,
-                end_angle,
-                color_stops,
-                extend,
-            } => {
-                let mut bridge_color_stops = BridgeColorStops {
-                    stops_iterator: Box::new(color_stops.iter()),
-                    num_stops: color_stops.len(),
-                };
-                color_painter.fill_sweep(
-                    c0.x,
-                    c0.y,
-                    start_angle,
-                    end_angle,
-                    &mut bridge_color_stops,
-                    extend as u8,
-                );
-            }
-        }
-    }
-
-    // TODO(drott): Add here an optimized paint function combining clip and fill.
-
-    fn push_layer(&mut self, composite_mode: CompositeMode) {
-        self.color_painter_wrapper
-            .as_mut()
-            .push_layer(composite_mode as u8);
-    }
-    fn pop_layer(&mut self) {
-        self.color_painter_wrapper.as_mut().pop_layer();
-    }
-}
-
 fn get_path(
     font_ref: &BridgeFontRef,
     glyph_id: u16,
@@ -245,10 +117,10 @@ fn convert_metrics(skrifa_metrics: &Metrics) -> ffi::Metrics {
         ascent: skrifa_metrics.ascent,
         descent: skrifa_metrics.descent,
         leading: skrifa_metrics.leading,
-        avg_char_width: skrifa_metrics.average_width.unwrap_or(0.0),
-        max_char_width: skrifa_metrics.max_width.unwrap_or(0.0),
-        x_height: skrifa_metrics.x_height.unwrap_or(0.0),
-        cap_height: skrifa_metrics.cap_height.unwrap_or(0.0),
+        avg_char_width: skrifa_metrics.average_width.unwrap_or_else(|| 0.0),
+        max_char_width: skrifa_metrics.max_width.unwrap_or_else(|| 0.0),
+        x_height: skrifa_metrics.x_height.unwrap_or_else(|| 0.0),
+        cap_height: skrifa_metrics.cap_height.unwrap_or_else(|| 0.0),
     }
 }
 
@@ -337,7 +209,7 @@ fn resolve_palette(
             let color_records = cpal.color_records_array()?.ok()?;
             let mut palette: Vec<u32> = color_records
                 .get(start_index..start_index + num_entries)?
-                .iter()
+                .into_iter()
                 .map(|record| {
                     u32::from_be_bytes([record.alpha, record.red, record.green, record.blue])
                 })
@@ -354,62 +226,6 @@ fn resolve_palette(
         .unwrap_or_default()
 }
 
-fn has_colr_glyph(font_ref: &BridgeFontRef, format: ColorGlyphFormat, glyph_id: u16) -> bool {
-    font_ref
-        .with_font(|f| {
-            let colrv1_paintable = f
-                .color_glyphs()
-                .get_with_format(GlyphId::new(glyph_id), format);
-            Some(colrv1_paintable.is_some())
-        })
-        .unwrap_or_default()
-}
-
-fn has_colrv1_glyph(font_ref: &BridgeFontRef, glyph_id: u16) -> bool {
-    has_colr_glyph(font_ref, ColorGlyphFormat::ColrV1, glyph_id)
-}
-
-fn has_colrv0_glyph(font_ref: &BridgeFontRef, glyph_id: u16) -> bool {
-    has_colr_glyph(font_ref, ColorGlyphFormat::ColrV0, glyph_id)
-}
-
-use crate::ffi::ClipBox;
-
-fn get_colrv1_clip_box(
-    font_ref: &BridgeFontRef,
-    coords: &BridgeNormalizedCoords,
-    glyph_id: u16,
-    size: f32,
-    clip_box: &mut ClipBox,
-) -> bool {
-    let size = match size {
-        x if x == 0.0 => {
-            return false;
-        }
-        _ => Size::new(size),
-    };
-    font_ref
-        .with_font(|f| {
-            match f
-                .color_glyphs()
-                .get_with_format(GlyphId::new(glyph_id), ColorGlyphFormat::ColrV1)?
-                .bounding_box(coords.normalized_coords.coords(), size)
-            {
-                Some(bounding_box) => {
-                    *clip_box = ClipBox {
-                        x_min: bounding_box.x_min,
-                        y_min: bounding_box.y_min,
-                        x_max: bounding_box.x_max,
-                        y_max: bounding_box.y_max,
-                    };
-                    Some(true)
-                }
-                _ => None,
-            }
-        })
-        .unwrap_or_default()
-}
-
 /// Implements the behavior expected for `SkTypeface::getTableData`, compare
 /// documentation for this method and the FreeType implementation in Skia.
 /// * If the target data array is empty, do not copy any data into it, but
@@ -461,7 +277,7 @@ fn variation_position(
     coords: &BridgeNormalizedCoords,
     coordinates: &mut [SkiaDesignCoordinate],
 ) -> isize {
-    if !coordinates.is_empty() {
+    if coordinates.len() > 0 {
         if coords.filtered_user_coords.len() > coordinates.len() {
             return -1;
         }
@@ -530,7 +346,7 @@ fn resolve_into_normalized_coords(
     design_coords: &[SkiaDesignCoordinate],
 ) -> Box<BridgeNormalizedCoords> {
     let variation_tuples = design_coords
-        .iter()
+        .into_iter()
         .map(|coord| (Tag::from_be_bytes(coord.axis.to_be_bytes()), coord.value));
     let bridge_normalized_coords = font_ref
         .with_font(|f| {
@@ -543,40 +359,6 @@ fn resolve_into_normalized_coords(
     Box::new(bridge_normalized_coords)
 }
 
-fn draw_colr_glyph(
-    font_ref: &BridgeFontRef,
-    coords: &BridgeNormalizedCoords,
-    glyph_id: u16,
-    color_painter: Pin<&mut ColorPainterWrapper>,
-) -> bool {
-    let mut color_painter_impl = ColorPainterImpl {
-        color_painter_wrapper: color_painter,
-    };
-    font_ref
-        .with_font(|f| {
-            let paintable = f.color_glyphs().get(GlyphId::new(glyph_id))?;
-            paintable
-                .paint(coords.normalized_coords.coords(), &mut color_painter_impl)
-                .ok()
-        })
-        .is_some()
-}
-
-fn next_color_stop(color_stops: &mut BridgeColorStops, out_stop: &mut ColorStop) -> bool {
-    if let Some(color_stop) = color_stops.stops_iterator.next() {
-        out_stop.alpha = color_stop.alpha;
-        out_stop.stop = color_stop.offset;
-        out_stop.palette_index = color_stop.palette_index;
-        return true;
-    } else {
-        return false;
-    }
-}
-
-fn num_color_stops(color_stops: &BridgeColorStops) -> usize {
-    return color_stops.num_stops;
-}
-
 struct BridgeFontRef<'a>(Option<FontRef<'a>>);
 
 impl<'a> BridgeFontRef<'a> {
@@ -596,18 +378,8 @@ struct BridgeLocalizedStrings<'a> {
     localized_strings: LocalizedStrings<'a>,
 }
 
-struct BridgeColorStops<'a> {
-    pub stops_iterator: Box<dyn Iterator<Item = &'a skrifa::color::ColorStop> + 'a>,
-    pub num_stops: usize,
-}
-
 #[cxx::bridge(namespace = "fontations_ffi")]
 mod ffi {
-    struct ColorStop {
-        stop: f32,
-        palette_index: u16,
-        alpha: f32,
-    }
 
     #[derive(Default)]
     struct Metrics {
@@ -643,14 +415,8 @@ mod ffi {
         color_8888: u32,
     }
 
-    struct ClipBox {
-        x_min: f32,
-        y_min: f32,
-        x_max: f32,
-        y_max: f32,
-    }
-
     extern "Rust" {
+
         type BridgeFontRef<'a>;
         unsafe fn make_font_ref<'a>(font_data: &'a [u8], index: u32) -> Box<BridgeFontRef<'a>>;
         // Returns whether BridgeFontRef is a valid font containing at
@@ -697,16 +463,6 @@ mod ffi {
             palette_overrides: &[PaletteOverride],
         ) -> Vec<u32>;
 
-        fn has_colrv1_glyph(font_ref: &BridgeFontRef, glyph_id: u16) -> bool;
-        fn has_colrv0_glyph(font_ref: &BridgeFontRef, glyph_id: u16) -> bool;
-        fn get_colrv1_clip_box(
-            font_ref: &BridgeFontRef,
-            coords: &BridgeNormalizedCoords,
-            glyph_id: u16,
-            size: f32,
-            clip_box: &mut ClipBox,
-        ) -> bool;
-
         fn table_data(font_ref: &BridgeFontRef, tag: u32, offset: usize, data: &mut [u8]) -> usize;
         fn table_tags(font_ref: &BridgeFontRef, tags: &mut [u32]) -> u16;
         fn variation_position(
@@ -731,17 +487,6 @@ mod ffi {
             design_coords: &[SkiaDesignCoordinate],
         ) -> Box<BridgeNormalizedCoords>;
 
-        fn draw_colr_glyph(
-            font_ref: &BridgeFontRef,
-            coords: &BridgeNormalizedCoords,
-            glyph_id: u16,
-            color_painter: Pin<&mut ColorPainterWrapper>,
-        ) -> bool;
-
-        type BridgeColorStops<'a>;
-        fn next_color_stop(color_stops: &mut BridgeColorStops, stop: &mut ColorStop) -> bool;
-        fn num_color_stops(color_stops: &BridgeColorStops) -> usize;
-
     }
 
     unsafe extern "C++" {
@@ -782,62 +527,6 @@ mod ffi {
         ) -> bool;
         fn size(self: Pin<&AxisWrapper>) -> usize;
 
-        type ColorPainterWrapper;
-
-        fn push_transform(
-            self: Pin<&mut ColorPainterWrapper>,
-            xx: f32,
-            xy: f32,
-            yx: f32,
-            yy: f32,
-            dx: f32,
-            dy: f32,
-        );
-        fn pop_transform(self: Pin<&mut ColorPainterWrapper>);
-        fn push_clip_glyph(self: Pin<&mut ColorPainterWrapper>, glyph_id: u16);
-        fn push_clip_rectangle(
-            self: Pin<&mut ColorPainterWrapper>,
-            x_min: f32,
-            y_min: f32,
-            x_max: f32,
-            y_max: f32,
-        );
-        fn pop_clip(self: Pin<&mut ColorPainterWrapper>);
-
-        fn fill_solid(self: Pin<&mut ColorPainterWrapper>, palette_index: u16, alpha: f32);
-        fn fill_radial(
-            self: Pin<&mut ColorPainterWrapper>,
-            x0: f32,
-            y0: f32,
-            r0: f32,
-            x1: f32,
-            y1: f32,
-            r1: f32,
-            color_stops: &mut BridgeColorStops,
-            extend_mode: u8,
-        );
-        fn fill_linear(
-            self: Pin<&mut ColorPainterWrapper>,
-            x0: f32,
-            y0: f32,
-            x1: f32,
-            y1: f32,
-            color_stops: &mut BridgeColorStops,
-            extend_mode: u8,
-        );
-        fn fill_sweep(
-            self: Pin<&mut ColorPainterWrapper>,
-            x0: f32,
-            y0: f32,
-            start_angle: f32,
-            end_angle: f32,
-            color_stops: &mut BridgeColorStops,
-            extend_mode: u8,
-        );
-
-        fn push_layer(self: Pin<&mut ColorPainterWrapper>, colrv1_composite_mode: u8);
-        fn pop_layer(self: Pin<&mut ColorPainterWrapper>);
-
     }
 }
 
diff --git a/src/ports/fontations/src/skpath_bridge.h b/src/ports/fontations/src/skpath_bridge.h
index df33753aa1..30e8ed8ad2 100644
--- a/src/ports/fontations/src/skpath_bridge.h
+++ b/src/ports/fontations/src/skpath_bridge.h
@@ -34,47 +34,6 @@ public:
     virtual size_t size() const = 0;
 };
 
-struct ColorStop;
-struct BridgeColorStops;
-
-/** C++ pure virtual interface, exposed to Rust side for receiving COLRv0/COLRv1 drawing callback
- * matching Skrifa's ColorPainter trait. */
-class ColorPainterWrapper {
-public:
-    virtual ~ColorPainterWrapper() = default;
-    virtual void push_transform(float xx, float xy, float yx, float yy, float dx, float dy) = 0;
-    virtual void pop_transform() = 0;
-    virtual void push_clip_glyph(uint16_t glyph_id) = 0;
-    virtual void push_clip_rectangle(float x_min, float y_min, float x_max, float y_max) = 0;
-    virtual void pop_clip() = 0;
-
-    // Paint*Gradient equivalents:
-    virtual void fill_solid(uint16_t palette_index, float alpha) = 0;
-    virtual void fill_linear(float x0,
-                             float y0,
-                             float x1,
-                             float y1,
-                             BridgeColorStops& stops,
-                             uint8_t extend_mode) = 0;
-    virtual void fill_radial(float x0,
-                             float y0,
-                             float r0,
-                             float x1,
-                             float y1,
-                             float r1,
-                             BridgeColorStops& stops,
-                             uint8_t extend_mode) = 0;
-    virtual void fill_sweep(float x0,
-                            float y0,
-                            float startAngle,
-                            float endAngle,
-                            BridgeColorStops& stops,
-                            uint8_t extend_mode) = 0;
-
-    virtual void push_layer(uint8_t colrV1CompositeMode) = 0;
-    virtual void pop_layer() = 0;
-};
-
 }  // namespace fontations_ffi
 
 #endif
-- 
2.40.1

