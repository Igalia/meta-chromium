From 56e9fde06388280f3aaa6e720b3669be1eac590b Mon Sep 17 00:00:00 2001
From: Alex Turner <alexmt@chromium.org>
Date: Thu, 19 Jan 2023 18:54:49 +0000
Subject: Roll distributed_point_functions library

Updates library to the latest version (dated 2023-01-17, commit
95a383908a4b39158ec0dd7da6cfe1088403bc5b). This should fix GCC AARCH64
compilation, which was broken by crrev.com/c/4035697.

This patch was generated by replacing the code/ directory with the
commit above and then applying the modifications listed in the README,
i.e. removing the non-dpf/ top-level directories and adding the
.clang-format file. The DEPS file was also updated to handle other
changes.

Change-Id: I30cfc44dbfdbdca2ed470106903c8244729d9c5c
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4178971
Reviewed-by: John Abd-El-Malek <jam@chromium.org>
Reviewed-by: Charlie Harrison <csharrison@chromium.org>
Commit-Queue: Alex Turner <alexmt@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1094584}
---
 third_party/distributed_point_functions/DEPS  |   4 +
 .../README.chromium                           |   4 +-
 .../code/WORKSPACE.bazel                      | 103 ++++++++++--------
 .../code/dpf/BUILD                            |   1 -
 .../code/dpf/aes_128_fixed_key_hash.h         |   3 +-
 .../code/dpf/aes_128_fixed_key_hash_test.cc   |   5 +-
 .../code/dpf/distributed_point_function.cc    |  26 ++++-
 .../code/dpf/distributed_point_function.h     |  11 +-
 .../distributed_point_function_benchmark.cc   |   4 +-
 .../dpf/distributed_point_function_test.cc    |   5 +-
 .../code/dpf/int_mod_n.h                      |   3 +-
 .../code/dpf/int_mod_n_benchmark.cc           |   3 +-
 .../code/dpf/int_mod_n_test.cc                |   5 +-
 .../aes_128_fixed_key_hash_hwy_test.cc        |  10 +-
 .../code/dpf/internal/evaluate_prg_hwy.cc     |  52 +++++----
 .../dpf/internal/evaluate_prg_hwy_test.cc     |  13 ++-
 .../code/dpf/internal/proto_validator_test.cc |   5 +-
 .../code/dpf/internal/status_matchers.h       |   3 +-
 .../dpf/internal/value_type_helpers_test.cc   |   5 +-
 .../code/dpf/tuple_test.cc                    |   3 +-
 .../code/dpf/xor_wrapper_test.cc              |   3 +-
 21 files changed, 161 insertions(+), 110 deletions(-)

diff --git a/third_party/distributed_point_functions/DEPS b/third_party/distributed_point_functions/DEPS
index 449aaf5268d3c..c99f58cef539f 100644
--- a/third_party/distributed_point_functions/DEPS
+++ b/third_party/distributed_point_functions/DEPS
@@ -2,8 +2,12 @@ include_rules = [
   "+absl",
   "+benchmark",
   "+dpf",
+  "+glog/logging.h",
+  "+gmock",
   "+google/protobuf",
+  "+gtest",
   "+hwy",
+  "+openssl",
 ]
 
 specific_include_rules = {
diff --git a/third_party/distributed_point_functions/README.chromium b/third_party/distributed_point_functions/README.chromium
index 081a0155120cb..f0ee9e2087bea 100644
--- a/third_party/distributed_point_functions/README.chromium
+++ b/third_party/distributed_point_functions/README.chromium
@@ -2,8 +2,8 @@ Name: The Incremental Distributed Point Functions library
 Short Name: distributed_point_functions
 URL: https://github.com/google/distributed_point_functions
 Version: 0
-Revision: 66ca98b060f51822cd371570e22461a98837b63b
-Date: 2022-11-23
+Revision: 95a383908a4b39158ec0dd7da6cfe1088403bc5b
+Date: 2023-01-17
 License: Apache 2.0
 License File: LICENSE
 Security Critical: Yes
diff --git a/third_party/distributed_point_functions/code/WORKSPACE.bazel b/third_party/distributed_point_functions/code/WORKSPACE.bazel
index 1d800b9f9ebb9..e9a16014e4019 100644
--- a/third_party/distributed_point_functions/code/WORKSPACE.bazel
+++ b/third_party/distributed_point_functions/code/WORKSPACE.bazel
@@ -4,11 +4,10 @@ load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
 # https://github.com/bazelbuild/rules_proto
 http_archive(
     name = "rules_proto",
-    sha256 = "a4382f78723af788f0bc19fd4c8411f44ffe0a72723670a34692ffad56ada3ac",
-    strip_prefix = "rules_proto-f7a30f6f80006b591fa7c437fe5a951eb10bcbcf",
+    sha256 = "0daa4fc5b2b820705fcbf239557515f9ab809be45a1e7c6dfaa1d465d5c615d4",
+    strip_prefix = "rules_proto-3f1ab99b718e3e7dd86ebdc49c580aa6a126b1cd",
     urls = [
-        "https://mirror.bazel.build/github.com/bazelbuild/rules_proto/archive/f7a30f6f80006b591fa7c437fe5a951eb10bcbcf.zip",
-        "https://github.com/bazelbuild/rules_proto/archive/f7a30f6f80006b591fa7c437fe5a951eb10bcbcf.zip",
+        "https://github.com/bazelbuild/rules_proto/archive/3f1ab99b718e3e7dd86ebdc49c580aa6a126b1cd.zip",
     ],
 )
 
@@ -19,13 +18,13 @@ rules_proto_dependencies()
 rules_proto_toolchains()
 
 # rules_cc defines rules for generating C++ code from Protocol Buffers.
+# https://github.com/bazelbuild/rules_cc
 http_archive(
     name = "rules_cc",
-    sha256 = "e0e0e15cd88a8cdc153268dddf698c921550c7a1819bba987b57d41b643d8e0a",
-    strip_prefix = "rules_cc-0a198b994a5d61412ea1622ce681d17dbdbdd027",
+    sha256 = "e17cca44563e0918a36a8ea2a50acb99ea9ad726bbd3cad8ba95a643a40121ab",
+    strip_prefix = "rules_cc-d7c11265cb157c9b962d87d9ab67b8c24e3a875f",
     urls = [
-        "https://mirror.bazel.build/github.com/bazelbuild/rules_cc/archive/0a198b994a5d61412ea1622ce681d17dbdbdd027.zip",
-        "https://github.com/bazelbuild/rules_cc/archive/0a198b994a5d61412ea1622ce681d17dbdbdd027.zip",
+        "https://github.com/bazelbuild/rules_cc/archive/d7c11265cb157c9b962d87d9ab67b8c24e3a875f.zip",
     ],
 )
 
@@ -34,13 +33,13 @@ load("@rules_cc//cc:repositories.bzl", "rules_cc_dependencies")
 rules_cc_dependencies()
 
 # io_bazel_rules_go defines rules for generating C++ code from Protocol Buffers.
+# https://github.com/bazelbuild/rules_go
 http_archive(
     name = "io_bazel_rules_go",
-    sha256 = "c1a2f7457c060aaeab0ed9b711b14a75c758297062a7b20fefbecd3504427677",
-    strip_prefix = "rules_go-707c634bf8f7ca5b57c2a923bec16fa62ced1fc7",
+    sha256 = "7c35e8515012279ef7bcbc39c4ef4b54a86756d853848cb621b7da49f156c82f",
+    strip_prefix = "rules_go-b397ab7ace3c4131f48b5f4d4d7e7e9e6809e0d2",
     urls = [
-        "https://mirror.bazel.build/github.com/bazelbuild/rules_go/archive/707c634bf8f7ca5b57c2a923bec16fa62ced1fc7.zip",
-        "https://github.com/bazelbuild/rules_go/archive/707c634bf8f7ca5b57c2a923bec16fa62ced1fc7.zip",
+        "https://github.com/bazelbuild/rules_go/archive/b397ab7ace3c4131f48b5f4d4d7e7e9e6809e0d2.zip",
     ],
 )
 
@@ -48,73 +47,76 @@ load("@io_bazel_rules_go//go:deps.bzl", "go_register_toolchains", "go_rules_depe
 
 go_rules_dependencies()
 
-go_register_toolchains(version = "1.15.5")
+go_register_toolchains(version = "1.19.3")
 
 # Install gtest.
+# https://github.com/google/googletest
 http_archive(
     name = "com_github_google_googletest",
-    sha256 = "1315261a037d90405714830edf4243fccd89950556353aa3d21095b6a1430ead",
-    strip_prefix = "googletest-6a5eb807493214be733d4cbb9f07f22fde25284f",
+    sha256 = "3e91944af2d909a79f18ee9760765624810146ccfae8f1a8f990037a1677d44b",
+    strip_prefix = "googletest-ac7a126f39d5bcd909b78c9e69900c76659b1bbb",
     urls = [
-        "https://mirror.bazel.build/github.com/google/googletest/archive/6a5eb807493214be733d4cbb9f07f22fde25284f.zip",
-        "https://github.com/google/googletest/archive/6a5eb807493214be733d4cbb9f07f22fde25284f.zip",
+        "https://github.com/google/googletest/archive/ac7a126f39d5bcd909b78c9e69900c76659b1bbb.zip",
     ],
 )
 
 # abseil-cpp
+# https://github.com/abseil/abseil-cpp
 http_archive(
     name = "com_google_absl",
-    sha256 = "c3b9d19cd38cd475f60b5756db1bdc6d10ed43e5c7ce7374eae9a57d763d0597",
-    strip_prefix = "abseil-cpp-ebab79b5783b3298ee2f31251174c660c322d7ef",
+    sha256 = "431c0c47217c36106f90e2ca4fcdf45af618ea21adde880804661b1ecb240056",
+    strip_prefix = "abseil-cpp-1fb3830b1cf685999bb2bbd0294be0a53c9440a6",
     urls = [
-        "https://github.com/abseil/abseil-cpp/archive/ebab79b5783b3298ee2f31251174c660c322d7ef.zip",
+        "https://github.com/abseil/abseil-cpp/archive/1fb3830b1cf685999bb2bbd0294be0a53c9440a6.zip",
     ],
 )
 
 # BoringSSL
+# https://github.com/google/boringssl
 http_archive(
     name = "boringssl",
-    sha256 = "0369cbbee0340c42576e760138e0e9a6a749fd570ad1f963ac764584893ca727",
-    strip_prefix = "boringssl-57e74c2c7f76111fda83f8f3955a82ec3a2bde44",
+    sha256 = "88e4330f4f65ebfdf24847e4807c25f3eacfd5bf1a93f6629d3941196ff9b0b3",
+    strip_prefix = "boringssl-6347808f2a480a3792148bf7732232229db9b909",
     urls = [
-        "https://github.com/google/boringssl/archive/57e74c2c7f76111fda83f8f3955a82ec3a2bde44.zip",
+        "https://github.com/google/boringssl/archive/6347808f2a480a3792148bf7732232229db9b909.zip",
     ],
 )
 
 # Benchmarks
+# https://github.com/google/benchmark
 http_archive(
     name = "com_github_google_benchmark",
-    sha256 = "d37d3fb186bbcc30018962185606869c032e866bc9ad376a6112fbb64fe6935f",
-    strip_prefix = "benchmark-5e387e7d33a55b8d6b7c5025379b97cc9418fabf",
+    sha256 = "5f98b44165f3250f1d749b728018318d654f763ea0f4d7ea156e10e6e0cc678a",
+    strip_prefix = "benchmark-5e78bedfb07c615edb2b646d1e354980268c1728",
     urls = [
-        "https://mirror.bazel.build/github.com/google/benchmark/archive/5e387e7d33a55b8d6b7c5025379b97cc9418fabf.zip",
-        "https://github.com/google/benchmark/archive/5e387e7d33a55b8d6b7c5025379b97cc9418fabf.zip",
+        "https://github.com/google/benchmark/archive/5e78bedfb07c615edb2b646d1e354980268c1728.zip",
     ],
 )
 
 # gflags needed for glog.
+# https://github.com/gflags/gflags
 http_archive(
     name = "com_github_gflags_gflags",
-    sha256 = "cfdba0f2f17e8b1ff75c98113d5080d8ec016148426abcc19130864e2952d7bd",
-    strip_prefix = "gflags-827c769e5fc98e0f2a34c47cef953cc6328abced",
+    sha256 = "017e0a91531bfc45be9eaf07e4d8fed33c488b90b58509dbd2e33a33b2648ae6",
+    strip_prefix = "gflags-a738fdf9338412f83ab3f26f31ac11ed3f3ec4bd",
     urls = [
-        "https://mirror.bazel.build/github.com/gflags/gflags/archive/827c769e5fc98e0f2a34c47cef953cc6328abced.zip",
-        "https://github.com/gflags/gflags/archive/827c769e5fc98e0f2a34c47cef953cc6328abced.zip",
+        "https://github.com/gflags/gflags/archive/a738fdf9338412f83ab3f26f31ac11ed3f3ec4bd.zip",
     ],
 )
 
 # glog for logging
+# https://github.com/google/glog
 http_archive(
     name = "com_github_google_glog",
-    sha256 = "8476f6b3be29b3ebecc7de058183d510acec6e6dcef35d416cc3ac407a3a5645",
-    strip_prefix = "glog-a79416bab739907a31a1e139540921ff0492f010",
+    sha256 = "0f91ee6cc1edc3b1c53a286382e69a37e5d172ce208b7e5b305be8770d8c21b1",
+    strip_prefix = "glog-f545ff5e7d7f3df95f6e86c8cb987d9d9d4bd481",
     urls = [
-        "https://mirror.bazel.build/github.com/google/glog/archive/a79416bab739907a31a1e139540921ff0492f010.zip",
-        "https://github.com/google/glog/archive/a79416bab739907a31a1e139540921ff0492f010.zip",
+        "https://github.com/google/glog/archive/f545ff5e7d7f3df95f6e86c8cb987d9d9d4bd481.zip",
     ],
 )
 
 # IREE for cc_embed_data.
+# https://github.com/google/iree
 http_archive(
     name = "com_github_google_iree",
     sha256 = "aa369b29a5c45ae9d7aa8bf49ea1308221d1711277222f0755df6e0a575f6879",
@@ -125,31 +127,44 @@ http_archive(
 )
 
 # riegeli for file IO
+# https://github.com/google/riegeli
 http_archive(
     name = "com_github_google_riegeli",
-    sha256 = "63253b1e0550657f590e0ac827c5f88af1829100a84ce1c8cec3777c9a5647c7",
-    strip_prefix = "riegeli-13e762cbeac9e0060914e83c9f326c3b6763078b",
+    sha256 = "3de21a222271a1e2c5d728e7f46b63ab4520da829c09ef9727a322e693c9ac18",
+    strip_prefix = "riegeli-43b7ef9f995469609b6ab07f6becc82186314bfb",
     urls = [
-        "https://github.com/google/riegeli/archive/13e762cbeac9e0060914e83c9f326c3b6763078b.zip",
+        "https://github.com/google/riegeli/archive/43b7ef9f995469609b6ab07f6becc82186314bfb.zip",
+    ],
+)
+
+# rules_license needed for Highway
+# https://github.com/bazelbuild/rules_license
+http_archive(
+    name = "rules_license",
+    sha256 = "6157e1e68378532d0241ecd15d3c45f6e5cfd98fc10846045509fb2a7cc9e381",
+    urls = [
+        "https://github.com/bazelbuild/rules_license/releases/download/0.0.4/rules_license-0.0.4.tar.gz",
     ],
 )
 
 # Highway for SIMD operations.
+# https://github.com/google/highway
 http_archive(
     name = "com_github_google_highway",
-    sha256 = "2b11bd6356a425015c8f524cb3b3804784c0dc895fb7f3f1c48460f0327b5b1e",
-    strip_prefix = "highway-1c3c2bc6417f69ccb598c440678048ac6a8a561e",
+    sha256 = "cdba0eb21796598dd50fa0a4aa3651fa466c0d37c39d149ee383f725434e4314",
+    strip_prefix = "highway-45c98184ab7f81cf592c07633070b75fced14a52",
     urls = [
-        "https://github.com/google/highway/archive/1c3c2bc6417f69ccb598c440678048ac6a8a561e.zip",
+        "https://github.com/google/highway/archive/45c98184ab7f81cf592c07633070b75fced14a52.zip",
     ],
 )
 
 # cppitertools for logging
+# https://github.com/ryanhaining/cppitertools
 http_archive(
     name = "com_github_ryanhaining_cppitertools",
-    sha256 = "83aedc4f593212d8112eac0b32b5f191219604f3db922cc218fd733ea448118c",
-    strip_prefix = "cppitertools-b2b98e60438f1ed6b04b77cdb6cc5d5516af301b",
+    sha256 = "1608ddbe3c12b0c6e653b992ff63b5dceab9af5347ad93be8714d05e5dc17afb",
+    strip_prefix = "cppitertools-add5acc932dea2c78acd80747bab71ec0b5bce27",
     urls = [
-        "https://github.com/ryanhaining/cppitertools/archive/b2b98e60438f1ed6b04b77cdb6cc5d5516af301b.zip",
+        "https://github.com/ryanhaining/cppitertools/archive/add5acc932dea2c78acd80747bab71ec0b5bce27.zip",
     ],
 )
diff --git a/third_party/distributed_point_functions/code/dpf/BUILD b/third_party/distributed_point_functions/code/dpf/BUILD
index 1e3dd7c46fb5f..600c53ff59ae5 100644
--- a/third_party/distributed_point_functions/code/dpf/BUILD
+++ b/third_party/distributed_point_functions/code/dpf/BUILD
@@ -64,7 +64,6 @@ cc_library(
         "@com_github_google_highway//:hwy",
         "@com_google_absl//absl/container:btree",
         "@com_google_absl//absl/container:flat_hash_map",
-        "@com_google_absl//absl/log",
         "@com_google_absl//absl/meta:type_traits",
         "@com_google_absl//absl/numeric:int128",
         "@com_google_absl//absl/status",
diff --git a/third_party/distributed_point_functions/code/dpf/aes_128_fixed_key_hash.h b/third_party/distributed_point_functions/code/dpf/aes_128_fixed_key_hash.h
index 863178e78c3c7..d791f506a07bb 100644
--- a/third_party/distributed_point_functions/code/dpf/aes_128_fixed_key_hash.h
+++ b/third_party/distributed_point_functions/code/dpf/aes_128_fixed_key_hash.h
@@ -17,10 +17,9 @@
 #ifndef DISTRIBUTED_POINT_FUNCTIONS_DPF_INTERNAL_AES_128_FIXED_KEY_HASH_H_
 #define DISTRIBUTED_POINT_FUNCTIONS_DPF_INTERNAL_AES_128_FIXED_KEY_HASH_H_
 
-#include <openssl/cipher.h>
-
 #include "absl/numeric/int128.h"
 #include "absl/status/statusor.h"
+#include "openssl/cipher.h"
 
 namespace distributed_point_functions {
 
diff --git a/third_party/distributed_point_functions/code/dpf/aes_128_fixed_key_hash_test.cc b/third_party/distributed_point_functions/code/dpf/aes_128_fixed_key_hash_test.cc
index 9c3bbd34475f2..229aa52258c2c 100644
--- a/third_party/distributed_point_functions/code/dpf/aes_128_fixed_key_hash_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/aes_128_fixed_key_hash_test.cc
@@ -16,10 +16,9 @@
 
 #include "dpf/aes_128_fixed_key_hash.h"
 
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
 #include "dpf/internal/status_matchers.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
 
 namespace distributed_point_functions {
 namespace {
diff --git a/third_party/distributed_point_functions/code/dpf/distributed_point_function.cc b/third_party/distributed_point_functions/code/dpf/distributed_point_function.cc
index 9cd18bd571e6e..dc8e2b3cc4b64 100644
--- a/third_party/distributed_point_functions/code/dpf/distributed_point_function.cc
+++ b/third_party/distributed_point_functions/code/dpf/distributed_point_function.cc
@@ -14,16 +14,15 @@
 
 #include "dpf/distributed_point_function.h"
 
-#include <glog/logging.h>
-#include <openssl/rand.h>
-
 #include <limits>
 
 #include "dpf/internal/evaluate_prg_hwy.h"
 #include "dpf/internal/get_hwy_mode.h"
 #include "dpf/status_macros.h"
+#include "glog/logging.h"
 #include "google/protobuf/io/zero_copy_stream_impl_lite.h"
 #include "hwy/aligned_allocator.h"
+#include "openssl/rand.h"
 
 namespace distributed_point_functions {
 
@@ -241,6 +240,9 @@ absl::Status DistributedPointFunction::EvaluateSeeds(
 
   // Parse correction words for each level.
   auto correction_seeds = hwy::AllocateAligned<absl::uint128>(num_levels);
+  if (correction_seeds == nullptr) {
+    return absl::ResourceExhaustedError("Memory allocation error");
+  }
   BitVector correction_controls_left(num_levels),
       correction_controls_right(num_levels);
   for (int level = 0; level < num_levels; ++level) {
@@ -283,12 +285,18 @@ DistributedPointFunction::ExpandSeeds(
   // Copy seeds and control bits. We will swap these after every expansion.
   DpfExpansion expansion;
   expansion.seeds = hwy::AllocateAligned<absl::uint128>(output_size);
+  if (expansion.seeds == nullptr) {
+    return absl::ResourceExhaustedError("Memory allocation error");
+  }
   std::copy_n(partial_evaluations.seeds.get(), current_level_size,
               expansion.seeds.get());
   expansion.control_bits = partial_evaluations.control_bits;
   expansion.control_bits.reserve(output_size);
   DpfExpansion next_level_expansion;
   next_level_expansion.seeds = hwy::AllocateAligned<absl::uint128>(output_size);
+  if (next_level_expansion.seeds == nullptr) {
+    return absl::ResourceExhaustedError("Memory allocation error");
+  }
   next_level_expansion.control_bits.reserve(output_size);
 
   // We use an iterative expansion here to pipeline AES as much as possible.
@@ -376,6 +384,9 @@ DistributedPointFunction::ComputePartialEvaluations(
     // `prefixes`.
     partial_evaluations.seeds =
         hwy::AllocateAligned<absl::uint128>(num_prefixes);
+    if (partial_evaluations.seeds == nullptr) {
+      return absl::ResourceExhaustedError("Memory allocation error");
+    }
     partial_evaluations.control_bits.reserve(num_prefixes);
     for (int64_t i = 0; i < num_prefixes; ++i) {
       absl::uint128 previous_prefix = 0;
@@ -397,6 +408,9 @@ DistributedPointFunction::ComputePartialEvaluations(
     // No partial evaluations in `ctx` -> Start from the beginning.
     partial_evaluations.seeds =
         hwy::AllocateAligned<absl::uint128>(num_prefixes);
+    if (partial_evaluations.seeds == nullptr) {
+      return absl::ResourceExhaustedError("Memory allocation error");
+    }
     auto seeds = absl::MakeSpan(partial_evaluations.seeds.get(), num_prefixes);
     std::fill(
         seeds.begin(), seeds.end(),
@@ -448,6 +462,9 @@ DistributedPointFunction::ExpandAndUpdateContext(
   if (prefixes.empty()) {
     // First expansion -> Expand seed of the DPF key.
     selected_partial_evaluations.seeds = hwy::AllocateAligned<absl::uint128>(1);
+    if (selected_partial_evaluations.seeds == nullptr) {
+      return absl::ResourceExhaustedError("Memory allocation error");
+    }
     selected_partial_evaluations.seeds[0] =
         absl::MakeUint128(ctx.key().seed().high(), ctx.key().seed().low());
     selected_partial_evaluations.control_bits = {
@@ -486,6 +503,9 @@ DistributedPointFunction::HashExpandedSeeds(
   const int blocks_needed = blocks_needed_[hierarchy_level];
   auto hashed_expansion =
       hwy::AllocateAligned<absl::uint128>(expansion_size * blocks_needed);
+  if (hashed_expansion == nullptr) {
+    return absl::ResourceExhaustedError("Memory allocation error");
+  }
   for (int64_t i = 0; i < expansion_size; ++i) {
     for (int j = 0; j < blocks_needed; ++j) {
       hashed_expansion[i * blocks_needed + j] = expansion[i] + j;
diff --git a/third_party/distributed_point_functions/code/dpf/distributed_point_function.h b/third_party/distributed_point_functions/code/dpf/distributed_point_function.h
index 4c998cc0105c4..5008f7489099b 100644
--- a/third_party/distributed_point_functions/code/dpf/distributed_point_function.h
+++ b/third_party/distributed_point_functions/code/dpf/distributed_point_function.h
@@ -17,9 +17,6 @@
 #ifndef DISTRIBUTED_POINT_FUNCTIONS_DPF_DISTRIBUTED_POINT_FUNCTION_H_
 #define DISTRIBUTED_POINT_FUNCTIONS_DPF_DISTRIBUTED_POINT_FUNCTION_H_
 
-#include <glog/logging.h>
-#include <openssl/cipher.h>
-
 #include <memory>
 #include <type_traits>
 
@@ -35,7 +32,9 @@
 #include "dpf/distributed_point_function.pb.h"
 #include "dpf/internal/proto_validator.h"
 #include "dpf/internal/value_type_helpers.h"
+#include "glog/logging.h"
 #include "hwy/aligned_allocator.h"
+#include "openssl/cipher.h"
 
 namespace distributed_point_functions {
 
@@ -909,6 +908,9 @@ absl::StatusOr<std::vector<T>> DistributedPointFunction::EvaluateAtImpl(
   if (elements_per_block > 1) {
     maybe_recomputed_tree_indices =
         hwy::AllocateAligned<absl::uint128>(num_evaluation_points);
+    if (maybe_recomputed_tree_indices == nullptr) {
+      return absl::ResourceExhaustedError("Memory allocation error");
+    }
     for (int64_t i = 0; i < num_evaluation_points; ++i) {
       maybe_recomputed_tree_indices[i] =
           DomainToTreeIndex(evaluation_points[i], hierarchy_level);
@@ -932,6 +934,9 @@ absl::StatusOr<std::vector<T>> DistributedPointFunction::EvaluateAtImpl(
     bool party = key.party();
     selected_partial_evaluations->seeds =
         hwy::AllocateAligned<absl::uint128>(num_evaluation_points);
+    if (selected_partial_evaluations->seeds == nullptr) {
+      return absl::ResourceExhaustedError("Memory allocation error");
+    }
     auto seeds = absl::MakeSpan(selected_partial_evaluations->seeds.get(),
                                 num_evaluation_points);
     std::fill(seeds.begin(), seeds.end(), seed);
diff --git a/third_party/distributed_point_functions/code/dpf/distributed_point_function_benchmark.cc b/third_party/distributed_point_functions/code/dpf/distributed_point_function_benchmark.cc
index 489716aa2b845..be5d5dddb8a05 100644
--- a/third_party/distributed_point_functions/code/dpf/distributed_point_function_benchmark.cc
+++ b/third_party/distributed_point_functions/code/dpf/distributed_point_function_benchmark.cc
@@ -12,13 +12,12 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include <glog/logging.h>
-
 #include "absl/container/btree_set.h"
 #include "absl/numeric/int128.h"
 #include "absl/random/random.h"
 #include "benchmark/benchmark.h"
 #include "dpf/distributed_point_function.h"
+#include "glog/logging.h"
 #include "hwy/aligned_allocator.h"
 
 namespace distributed_point_functions {
@@ -365,6 +364,7 @@ void BM_BatchEvaluation(benchmark::State& state) {
   std::vector<const DpfKey*> key_pointers(num_keys * evaluation_points_per_key);
   auto evaluation_points =
       hwy::AllocateAligned<absl::uint128>(num_keys * evaluation_points_per_key);
+  CHECK(evaluation_points != nullptr);
   for (int i = 0; i < num_keys; ++i) {
     absl::uint128 alpha = absl::MakeUint128(absl::Uniform<uint64_t>(rng),
                                             absl::Uniform<uint64_t>(rng)) &
diff --git a/third_party/distributed_point_functions/code/dpf/distributed_point_function_test.cc b/third_party/distributed_point_functions/code/dpf/distributed_point_function_test.cc
index 922b748634e2b..372a3411597b0 100644
--- a/third_party/distributed_point_functions/code/dpf/distributed_point_function_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/distributed_point_function_test.cc
@@ -14,15 +14,14 @@
 
 #include "dpf/distributed_point_function.h"
 
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
 #include "absl/numeric/int128.h"
 #include "absl/random/random.h"
 #include "absl/strings/str_format.h"
 #include "absl/utility/utility.h"
 #include "dpf/distributed_point_function.pb.h"
 #include "dpf/internal/status_matchers.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
 
 namespace distributed_point_functions {
 namespace {
diff --git a/third_party/distributed_point_functions/code/dpf/int_mod_n.h b/third_party/distributed_point_functions/code/dpf/int_mod_n.h
index 1e522375323a0..33764a677fefd 100644
--- a/third_party/distributed_point_functions/code/dpf/int_mod_n.h
+++ b/third_party/distributed_point_functions/code/dpf/int_mod_n.h
@@ -17,14 +17,13 @@
 #ifndef DISTRIBUTED_POINT_FUNCTIONS_DPF_INTERNAL_INT_MOD_N_H_
 #define DISTRIBUTED_POINT_FUNCTIONS_DPF_INTERNAL_INT_MOD_N_H_
 
-#include <glog/logging.h>
-
 #include "absl/container/inlined_vector.h"
 #include "absl/numeric/int128.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
+#include "glog/logging.h"
 
 namespace distributed_point_functions {
 
diff --git a/third_party/distributed_point_functions/code/dpf/int_mod_n_benchmark.cc b/third_party/distributed_point_functions/code/dpf/int_mod_n_benchmark.cc
index 1d7f53d77aba7..1551d1c9ab63e 100644
--- a/third_party/distributed_point_functions/code/dpf/int_mod_n_benchmark.cc
+++ b/third_party/distributed_point_functions/code/dpf/int_mod_n_benchmark.cc
@@ -12,12 +12,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include <openssl/rand.h>
-
 #include "absl/status/status.h"
 #include "absl/types/span.h"
 #include "benchmark/benchmark.h"
 #include "dpf/int_mod_n.h"
+#include "openssl/rand.h"
 
 namespace distributed_point_functions {
 namespace {
diff --git a/third_party/distributed_point_functions/code/dpf/int_mod_n_test.cc b/third_party/distributed_point_functions/code/dpf/int_mod_n_test.cc
index c8a54c1f8703b..8f582160f6993 100644
--- a/third_party/distributed_point_functions/code/dpf/int_mod_n_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/int_mod_n_test.cc
@@ -14,15 +14,14 @@
 
 #include "dpf/int_mod_n.h"
 
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
 #include <cstdint>
 
 #include "absl/numeric/int128.h"
 #include "absl/status/status.h"
 #include "absl/types/span.h"
 #include "dpf/internal/status_matchers.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
 
 namespace distributed_point_functions {
 namespace {
diff --git a/third_party/distributed_point_functions/code/dpf/internal/aes_128_fixed_key_hash_hwy_test.cc b/third_party/distributed_point_functions/code/dpf/internal/aes_128_fixed_key_hash_hwy_test.cc
index 21c6e89125adf..5adfdafafcba8 100644
--- a/third_party/distributed_point_functions/code/dpf/internal/aes_128_fixed_key_hash_hwy_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/internal/aes_128_fixed_key_hash_hwy_test.cc
@@ -12,10 +12,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include <glog/logging.h>
-#include <gtest/gtest.h>
-#include <openssl/aes.h>
-
 #include <limits>
 #include <numeric>
 
@@ -24,8 +20,11 @@
 #include "dpf/aes_128_fixed_key_hash.h"
 #include "dpf/internal/get_hwy_mode.h"
 #include "dpf/internal/status_matchers.h"
+#include "glog/logging.h"
+#include "gtest/gtest.h"
 #include "hwy/aligned_allocator.h"
 #include "hwy/detect_targets.h"
+#include "openssl/aes.h"
 
 // clang-format off
 #define HWY_IS_TEST 1
@@ -75,13 +74,16 @@ class TestOutputMatchesOpenSSL {
  private:
   void Reset() {
     inputs_ = hwy::AllocateAligned<absl::uint128>(kNumBlocks);
+    ASSERT_NE(inputs_, nullptr);
     masks_ = hwy::AllocateAligned<uint64_t>(2 * kNumBlocks);
+    ASSERT_NE(masks_, nullptr);
     for (int i = 0; i < kNumBlocks; ++i) {
       inputs_[i] = absl::MakeUint128(i, i + 1);
       masks_[2 * i] = masks_[2 * i + 1] =
           (i % 3 == 0) ? std::numeric_limits<uint64_t>::max() : 0;
     }
     outputs_ = hwy::AllocateAligned<absl::uint128>(kNumBlocks);
+    ASSERT_NE(outputs_, nullptr);
     ASSERT_EQ(0, AES_set_encrypt_key(reinterpret_cast<const uint8_t*>(&kKey0),
                                      128, &expanded_key_0_));
     ASSERT_EQ(0, AES_set_encrypt_key(reinterpret_cast<const uint8_t*>(&kKey1),
diff --git a/third_party/distributed_point_functions/code/dpf/internal/evaluate_prg_hwy.cc b/third_party/distributed_point_functions/code/dpf/internal/evaluate_prg_hwy.cc
index 18af228554730..8a51745569408 100644
--- a/third_party/distributed_point_functions/code/dpf/internal/evaluate_prg_hwy.cc
+++ b/third_party/distributed_point_functions/code/dpf/internal/evaluate_prg_hwy.cc
@@ -14,9 +14,6 @@
 
 #include "dpf/internal/evaluate_prg_hwy.h"
 
-#include <glog/logging.h>
-#include <openssl/aes.h>
-
 #include <cstdint>
 #include <limits>
 
@@ -25,7 +22,9 @@
 #include "absl/numeric/int128.h"
 #include "absl/status/status.h"
 #include "dpf/status_macros.h"
+#include "glog/logging.h"
 #include "hwy/aligned_allocator.h"
+#include "openssl/aes.h"
 
 // clang-format off
 #undef HWY_TARGET_INCLUDE
@@ -124,14 +123,14 @@ auto IsBitSet(D d, const V input, int index) {
 
   // Compute input AND index_64 on 64-bit integers.
   auto input_64 = hn::BitCast(d64, input);
-  input_64 &= index_64;
+  input_64 = hn::And(input_64, index_64);
 
   // Take the OR of every two adjacent 64-bit integers. This ensures that each
   // half of an 128-bit block is nonzero iff at least one half was nonzero.
-  input_64 |= hn::Shuffle01(input_64);
+  input_64 = hn::Or(input_64, hn::Shuffle01(input_64));
 
   // Compute a 64-bit mask that checks which integers are nonzero.
-  return input_64 != hn::Zero(d64);
+  return hn::Ne(input_64, hn::Zero(d64));
 }
 
 // Dummy struct to get HWY_ALIGN as a number, for testing if an array of
@@ -236,24 +235,28 @@ absl::Status EvaluateSeedsHwy(
       // Apply correction.
       const auto correction_seed = hn::LoadDup128(
           d64, reinterpret_cast<const uint64_t*>(correction_seeds + j));
-      vec_0 ^=
-          hn::BitCast(d8, hn::IfThenElseZero(control_mask_0, correction_seed));
-      vec_1 ^=
-          hn::BitCast(d8, hn::IfThenElseZero(control_mask_1, correction_seed));
-      vec_2 ^=
-          hn::BitCast(d8, hn::IfThenElseZero(control_mask_2, correction_seed));
-      vec_3 ^=
-          hn::BitCast(d8, hn::IfThenElseZero(control_mask_3, correction_seed));
+      vec_0 = hn::Xor(
+          vec_0,
+          hn::BitCast(d8, hn::IfThenElseZero(control_mask_0, correction_seed)));
+      vec_1 = hn::Xor(
+          vec_1,
+          hn::BitCast(d8, hn::IfThenElseZero(control_mask_1, correction_seed)));
+      vec_2 = hn::Xor(
+          vec_2,
+          hn::BitCast(d8, hn::IfThenElseZero(control_mask_2, correction_seed)));
+      vec_3 = hn::Xor(
+          vec_3,
+          hn::BitCast(d8, hn::IfThenElseZero(control_mask_3, correction_seed)));
 
       // Extract control bit for next level.
       const auto next_control_mask_0 = IsBitSet(d8, vec_0, 0);
       const auto next_control_mask_1 = IsBitSet(d8, vec_1, 0);
       const auto next_control_mask_2 = IsBitSet(d8, vec_2, 0);
       const auto next_control_mask_3 = IsBitSet(d8, vec_3, 0);
-      vec_0 &= clear_lowest_bit;
-      vec_1 &= clear_lowest_bit;
-      vec_2 &= clear_lowest_bit;
-      vec_3 &= clear_lowest_bit;
+      vec_0 = hn::And(vec_0, clear_lowest_bit);
+      vec_1 = hn::And(vec_1, clear_lowest_bit);
+      vec_2 = hn::And(vec_2, clear_lowest_bit);
+      vec_3 = hn::And(vec_3, clear_lowest_bit);
 
       // Perform control bit correction.
       const auto correction_control_mask_left =
@@ -321,10 +324,11 @@ absl::Status EvaluateSeedsHwy(
       // Apply correction.
       const auto correction_seed = hn::LoadDup128(
           d64, reinterpret_cast<const uint64_t*>(correction_seeds + j));
-      vec ^= hn::BitCast(d8, hn::IfThenElseZero(control_mask, correction_seed));
+      vec = hn::Xor(vec, hn::BitCast(d8, hn::IfThenElseZero(control_mask,
+                                                            correction_seed)));
       // Extract control bit for next level.
       const auto next_control_mask = IsBitSet(d8, vec, 0);
-      vec &= clear_lowest_bit;
+      vec = hn::And(vec, clear_lowest_bit);
 
       // Perform control bit correction.
       const auto correction_control_mask_left =
@@ -353,6 +357,9 @@ absl::Status EvaluateSeedsHwy(
     // to read. Calling MaskedLoad directly instead might lead to out-of-bounds
     // accesses.
     auto buffer = hwy::AllocateAligned<absl::uint128>(2 * blocks_per_lane);
+    if (buffer == nullptr) {
+      return absl::ResourceExhaustedError("Memory allocation error");
+    }
     auto buffer_ptr = reinterpret_cast<uint8_t*>(buffer.get());
     std::copy_n(seeds_in + i / sizeof(absl::uint128), remaining_blocks,
                 buffer.get());
@@ -373,9 +380,10 @@ absl::Status EvaluateSeedsHwy(
       // Perform seed correction.
       const auto correction_seed = hn::LoadDup128(
           d64, reinterpret_cast<const uint64_t*>(correction_seeds + j));
-      vec ^= hn::BitCast(d8, hn::IfThenElseZero(control_mask, correction_seed));
+      vec = hn::Xor(vec, hn::BitCast(d8, hn::IfThenElseZero(control_mask,
+                                                            correction_seed)));
       const auto next_control_mask = IsBitSet(d8, vec, 0);
-      vec &= clear_lowest_bit;
+      vec = hn::And(vec, clear_lowest_bit);
       const auto correction_control_mask_left =
           correction_controls_left[j] ? mask_all_one : mask_all_zero;
       const auto correction_control_mask_right =
diff --git a/third_party/distributed_point_functions/code/dpf/internal/evaluate_prg_hwy_test.cc b/third_party/distributed_point_functions/code/dpf/internal/evaluate_prg_hwy_test.cc
index b88648a30325c..990f13d1c582f 100644
--- a/third_party/distributed_point_functions/code/dpf/internal/evaluate_prg_hwy_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/internal/evaluate_prg_hwy_test.cc
@@ -14,11 +14,10 @@
 
 #include "dpf/internal/evaluate_prg_hwy.h"
 
-#include <gtest/gtest.h>
-
 #include "absl/numeric/int128.h"
 #include "dpf/aes_128_fixed_key_hash.h"
 #include "dpf/internal/status_matchers.h"
+#include "gtest/gtest.h"
 #include "hwy/aligned_allocator.h"
 
 // clang-format off
@@ -46,8 +45,11 @@ void TestOutputMatchesNoHwyVersion(int num_seeds, int num_levels) {
   hwy::AlignedFreeUniquePtr<bool[]> control_bits_in;
   if (num_seeds > 0) {
     seeds_in = hwy::AllocateAligned<absl::uint128>(num_seeds);
+    ASSERT_NE(seeds_in, nullptr);
     paths = hwy::AllocateAligned<absl::uint128>(num_seeds);
+    ASSERT_NE(paths, nullptr);
     control_bits_in = hwy::AllocateAligned<bool>(num_seeds);
+    ASSERT_NE(control_bits_in, nullptr);
   }
   for (int i = 0; i < num_seeds; ++i) {
     // All of these are arbitrary.
@@ -59,7 +61,9 @@ void TestOutputMatchesNoHwyVersion(int num_seeds, int num_levels) {
   hwy::AlignedFreeUniquePtr<bool[]> control_bits_out;
   if (num_seeds > 0) {
     seeds_out = hwy::AllocateAligned<absl::uint128>(num_seeds);
+    ASSERT_NE(seeds_out, nullptr);
     control_bits_out = hwy::AllocateAligned<bool>(num_seeds);
+    ASSERT_NE(control_bits_out, nullptr);
   }
 
   // Generate correction words.
@@ -68,8 +72,11 @@ void TestOutputMatchesNoHwyVersion(int num_seeds, int num_levels) {
       correction_controls_right;
   if (num_levels > 0) {
     correction_seeds = hwy::AllocateAligned<absl::uint128>(num_levels);
+    ASSERT_NE(correction_seeds, nullptr);
     correction_controls_left = hwy::AllocateAligned<bool>(num_levels);
+    ASSERT_NE(correction_controls_left, nullptr);
     correction_controls_right = hwy::AllocateAligned<bool>(num_levels);
+    ASSERT_NE(correction_controls_right, nullptr);
   }
   for (int i = 0; i < num_levels; ++i) {
     correction_seeds[i] = absl::MakeUint128(i + 1, i);
@@ -97,7 +104,9 @@ void TestOutputMatchesNoHwyVersion(int num_seeds, int num_levels) {
   hwy::AlignedFreeUniquePtr<bool[]> control_bits_out_wanted;
   if (num_seeds > 0) {
     seeds_out_wanted = hwy::AllocateAligned<absl::uint128>(num_seeds);
+    ASSERT_NE(seeds_out_wanted, nullptr);
     control_bits_out_wanted = hwy::AllocateAligned<bool>(num_seeds);
+    ASSERT_NE(control_bits_out_wanted, nullptr);
   }
   DPF_ASSERT_OK(EvaluateSeedsNoHwy(
       num_seeds, num_levels, seeds_in.get(), control_bits_in.get(), paths.get(),
diff --git a/third_party/distributed_point_functions/code/dpf/internal/proto_validator_test.cc b/third_party/distributed_point_functions/code/dpf/internal/proto_validator_test.cc
index 31f81ee26e198..4f5bfa6389206 100644
--- a/third_party/distributed_point_functions/code/dpf/internal/proto_validator_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/internal/proto_validator_test.cc
@@ -14,14 +14,13 @@
 
 #include "dpf/internal/proto_validator.h"
 
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
 #include "absl/strings/str_format.h"
 #include "dpf/internal/proto_validator_test_textproto_embed.h"
 #include "dpf/internal/status_matchers.h"
 #include "dpf/tuple.h"
+#include "gmock/gmock.h"
 #include "google/protobuf/text_format.h"
+#include "gtest/gtest.h"
 
 namespace distributed_point_functions {
 namespace dpf_internal {
diff --git a/third_party/distributed_point_functions/code/dpf/internal/status_matchers.h b/third_party/distributed_point_functions/code/dpf/internal/status_matchers.h
index 008f6b9a5ac28..5cdebecfccfaa 100644
--- a/third_party/distributed_point_functions/code/dpf/internal/status_matchers.h
+++ b/third_party/distributed_point_functions/code/dpf/internal/status_matchers.h
@@ -116,13 +116,12 @@
 #ifndef DISTRIBUTED_POINT_FUNCTIONS_DPF_UTIL_STATUS_MATCHERS_H_
 #define DISTRIBUTED_POINT_FUNCTIONS_DPF_UTIL_STATUS_MATCHERS_H_
 
-#include <gmock/gmock.h>
-
 #include <string>
 
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "dpf/status_macros.h"
+#include "gmock/gmock.h"
 
 namespace distributed_point_functions {
 namespace dpf_internal {
diff --git a/third_party/distributed_point_functions/code/dpf/internal/value_type_helpers_test.cc b/third_party/distributed_point_functions/code/dpf/internal/value_type_helpers_test.cc
index 44ecac698e3e9..bcdd01f3c12e1 100644
--- a/third_party/distributed_point_functions/code/dpf/internal/value_type_helpers_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/internal/value_type_helpers_test.cc
@@ -14,10 +14,9 @@
 
 #include "dpf/internal/value_type_helpers.h"
 
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
 #include "dpf/internal/status_matchers.h"
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
 
 namespace distributed_point_functions {
 namespace dpf_internal {
diff --git a/third_party/distributed_point_functions/code/dpf/tuple_test.cc b/third_party/distributed_point_functions/code/dpf/tuple_test.cc
index 52c224a86f88c..26d499668adb9 100644
--- a/third_party/distributed_point_functions/code/dpf/tuple_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/tuple_test.cc
@@ -14,9 +14,8 @@
 
 #include "dpf/tuple.h"
 
-#include <gtest/gtest.h>
-
 #include "absl/numeric/int128.h"
+#include "gtest/gtest.h"
 
 namespace distributed_point_functions {
 
diff --git a/third_party/distributed_point_functions/code/dpf/xor_wrapper_test.cc b/third_party/distributed_point_functions/code/dpf/xor_wrapper_test.cc
index c23603df87d63..2a23f0d0cadc4 100644
--- a/third_party/distributed_point_functions/code/dpf/xor_wrapper_test.cc
+++ b/third_party/distributed_point_functions/code/dpf/xor_wrapper_test.cc
@@ -14,9 +14,8 @@
 
 #include "dpf/xor_wrapper.h"
 
-#include <gtest/gtest.h>
-
 #include "absl/numeric/int128.h"
+#include "gtest/gtest.h"
 
 namespace distributed_point_functions {
 
-- 
2.37.2

